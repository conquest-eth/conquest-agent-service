{
  "address": "0xB9D19010237254cf6c818afDDB399F3402EB50e4",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract AllianceRegistry",
          "name": "allianceRegistry",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "nonce",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct AllianceRegistry.PlayerSubmission[]",
          "name": "playerSubmissions",
          "type": "tuple[]"
        }
      ],
      "name": "addMembers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "admin",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "initialAdmin",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "nonce",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct AllianceRegistry.PlayerSubmission[]",
          "name": "playerSubmissions",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "instantiate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "addr",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "nonce",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct AllianceRegistry.PlayerSubmission[]",
          "name": "playerSubmissions",
          "type": "tuple[]"
        }
      ],
      "name": "setAdminAndAddMembers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5e260db433423da4d5d64c630c42808f21eab6e9fd0743f2f55eea609818d620",
  "receipt": {
    "to": null,
    "from": "0x61c461EcC993aaDEB7e4b47E96d1B8cC37314B20",
    "contractAddress": "0xB9D19010237254cf6c818afDDB399F3402EB50e4",
    "transactionIndex": 7,
    "gasUsed": "602301",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x58b60fbf91ae450c9ab1cbf6f1286b54c09b5c9304f03aea6a6cadc15f5a6833",
    "transactionHash": "0x5e260db433423da4d5d64c630c42808f21eab6e9fd0743f2f55eea609818d620",
    "logs": [],
    "blockNumber": 6217819,
    "cumulativeGasUsed": "837600",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xFDfD26F26AD38FA6d069E446Cd23CD6c432048B1"
  ],
  "numDeployments": 1,
  "solcInputHash": "037e1197a23bd7a7f8dec81bf3363a15",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract AllianceRegistry\",\"name\":\"allianceRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct AllianceRegistry.PlayerSubmission[]\",\"name\":\"playerSubmissions\",\"type\":\"tuple[]\"}],\"name\":\"addMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAdmin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct AllianceRegistry.PlayerSubmission[]\",\"name\":\"playerSubmissions\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"instantiate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct AllianceRegistry.PlayerSubmission[]\",\"name\":\"playerSubmissions\",\"type\":\"tuple[]\"}],\"name\":\"setAdminAndAddMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/Alliances/BasicAlliance.sol\":\"BasicAlliance\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xa3bbab77849522b73d8c6cd3d2ac54bef7580e4354484f35f4cabf55d3d2b3f9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"src/AllianceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-1.0\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\nimport \\\"./Interfaces/IAlliance.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract AllianceRegistry is Proxied {\\n     using ECDSA for bytes32;\\n\\n\\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\\n\\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\\n    struct AllianceRow {\\n        IAlliance alliance;\\n        uint96 joinTime;\\n    }\\n    struct Alliances {\\n        AllianceRow alliance0;\\n        AllianceRow alliance1;\\n        AllianceRow alliance2;\\n        AllianceRow alliance3;\\n    }\\n    mapping(address => Alliances) internal _alliances;\\n\\n\\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\\n\\n\\n    function getAllianceDataAtSlot(address player, uint8 slot) external view returns (IAlliance alliance, uint96 joinTime, uint256 nonce) {\\n\\n        Alliances storage alliances = _alliances[player];\\n        if (slot == 0) {\\n            alliance = alliances.alliance0.alliance;\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (slot == 1) {\\n            alliance = alliances.alliance1.alliance;\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (slot == 2) {\\n            alliance = alliances.alliance2.alliance;\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (slot == 3) {\\n            alliance = alliances.alliance3.alliance;\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n\\n        nonce = _allianceNonces[player][alliance];\\n    }\\n\\n    function getAllianceData(address player, IAlliance alliance) external view returns (uint96 joinTime, uint256 nonce) {\\n        nonce = _allianceNonces[player][alliance];\\n\\n        Alliances storage alliances = _alliances[player];\\n        if (alliances.alliance0.alliance == alliance) {\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (alliances.alliance1.alliance == alliance) {\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (alliances.alliance2.alliance == alliance) {\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (alliances.alliance3.alliance == alliance) {\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n    }\\n\\n    function havePlayersAnAllianceInCommon(address player1, address player2, uint256 timestamp) external view returns (IAlliance alliance, uint96 joinTime) {\\n        Alliances storage p1Alliances = _alliances[player1];\\n        Alliances storage p2Alliances = _alliances[player2];\\n\\n        AllianceRow[4] memory player1Alliances;\\n        AllianceRow[4] memory player2Alliances;\\n        uint256 num1 = 0;\\n        uint256 num2 = 0;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (i == num1) {\\n                AllianceRow memory allianceRow;\\n                if (i == 0) {\\n                    allianceRow = p1Alliances.alliance0;\\n                } else if(i==1) {\\n                    allianceRow = p1Alliances.alliance1;\\n                } else if(i==2) {\\n                    allianceRow = p1Alliances.alliance2;\\n                } else if(i==3) {\\n                    allianceRow = p1Alliances.alliance3;\\n                }\\n                if (address(allianceRow.alliance) == address(0)) {\\n                    // console.log(\\\"p1 exhausted\\\");\\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                }\\n                player1Alliances[num1 ++] = allianceRow;\\n            }\\n            for (uint256 j = 0; j < 4; j++) {\\n                if (j == num2) {\\n                    AllianceRow memory allianceRow;\\n                    if (j == 0) {\\n                        allianceRow = p2Alliances.alliance0;\\n                    } else if(j==1) {\\n                        allianceRow = p2Alliances.alliance1;\\n                    } else if(j==2) {\\n                        allianceRow = p2Alliances.alliance2;\\n                    } else if(j==3) {\\n                        allianceRow = p2Alliances.alliance3;\\n                    }\\n                    if (address(allianceRow.alliance) == address(0)) {\\n                        // console.log(\\\"p2 exhausted\\\");\\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                        break;\\n                    }\\n                    player2Alliances[num2 ++] = allianceRow;\\n                }\\n\\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\\n                        if (player1Alliances[i].joinTime < timestamp) {\\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player1Alliances[i].alliance;\\n                            joinTime = player1Alliances[i].joinTime;\\n                        }\\n                    } else {\\n                        if (player2Alliances[j].joinTime < timestamp) {\\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player2Alliances[j].alliance;\\n                            joinTime = player2Alliances[j].joinTime;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // console.log(address(alliance));\\n        // console.log(joinTime);\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM PLAYER\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\\n        Alliances storage alliances = _alliances[msg.sender];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            slot ++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            slot ++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            slot ++;\\n        }\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n        joined = alliance.requestToJoin(msg.sender, data);\\n        if (joined) {\\n            if (slot == 0) {\\n                alliances.alliance0.alliance = alliance;\\n                alliances.alliance0.joinTime = uint96(block.timestamp);\\n            } else if (slot == 1) {\\n                alliances.alliance1.alliance = alliance;\\n                alliances.alliance1.joinTime = uint96(block.timestamp);\\n            } else if (slot == 2) {\\n                alliances.alliance2.alliance = alliance;\\n                alliances.alliance2.joinTime = uint96(block.timestamp);\\n            } else if (slot == 3) {\\n                alliances.alliance3.alliance = alliance;\\n                alliances.alliance3.joinTime = uint96(block.timestamp);\\n            }\\n\\n            emit AllianceLink(alliance, msg.sender, true);\\n        }\\n    }\\n\\n    function leaveAlliance(IAlliance alliance) external {\\n        _leaveAlliance(msg.sender, alliance);\\n        try alliance.playerHasLeft(msg.sender) {} catch {}\\n        // TODO ensure callback not failed due to low gas (1/64 rule)\\n    }\\n\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM ALLIANCE\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function addPlayerToAlliance(address player, uint32 nonce, bytes calldata signature) external {\\n        _addPlayerToAlliance(player, nonce, signature);\\n    }\\n\\n    struct PlayerSubmission {\\n        address addr;\\n        uint32 nonce;\\n        bytes signature;\\n    }\\n\\n\\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\\n       for(uint256 i = 0 ; i < playerSubmissions.length; i++) {\\n           _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\\n       }\\n    }\\n\\n    function ejectPlayerFromAlliance(address player) external {\\n        _leaveAlliance(player, IAlliance(msg.sender));\\n    }\\n\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // INTERNAL\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function _addPlayerToAlliance(address player, uint32 nonce, bytes calldata signature) internal {\\n        IAlliance alliance = IAlliance(msg.sender);\\n\\n        Alliances storage alliances = _alliances[player];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            require(alliances.alliance0.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot ++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            require(alliances.alliance1.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot ++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            require(alliances.alliance2.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot ++;\\n        }\\n        require(alliances.alliance3.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n\\n        uint256 currentNonce = _allianceNonces[player][alliance];\\n        require(currentNonce == nonce, \\\"INVALID_NONCE\\\");\\n\\n        bytes memory message;\\n        if (nonce == 0) {\\n            message = abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n56\\\", \\\"Join Alliance 0x0000000000000000000000000000000000000000\\\");\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n        } else {\\n            message = abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n76\\\", \\\"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\\\");\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n            _writeUintAsDecimal(message, 28 + 74, nonce);\\n        }\\n\\n\\n        // console.log(string(message));\\n\\n        bytes32 digest = keccak256(message);\\n\\n        address signer = digest.recover(signature);\\n        require(player == signer, \\\"INVALID_SIGNATURE\\\");\\n\\n        if (slot == 0) {\\n            alliances.alliance0.alliance = alliance;\\n            alliances.alliance0.joinTime = uint96(block.timestamp);\\n        } else if (slot == 1) {\\n            alliances.alliance1.alliance = alliance;\\n            alliances.alliance1.joinTime = uint96(block.timestamp);\\n        } else if (slot == 2) {\\n            alliances.alliance2.alliance = alliance;\\n            alliances.alliance2.joinTime = uint96(block.timestamp);\\n        } else if (slot == 3) {\\n            alliances.alliance3.alliance = alliance;\\n            alliances.alliance3.joinTime = uint96(block.timestamp);\\n        }\\n        _allianceNonces[player][alliance] = nonce + 1;\\n\\n        emit AllianceLink(alliance, player, true);\\n    }\\n\\n    bytes internal constant hexAlphabet = \\\"0123456789abcdef\\\";\\n    bytes internal constant decimalAlphabet = \\\"0123456789\\\";\\n    function _writeUintAsHex(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\\n            num /= 16;\\n        }\\n    }\\n    function _writeUintAsDecimal(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\\n            num /= 10;\\n        }\\n    }\\n\\n    function _leaveAlliance(address player, IAlliance alliance) internal {\\n\\n        Alliances storage alliances = _alliances[msg.sender];\\n\\n        IAlliance lastSlotAlliance;\\n        uint96 lastSlotJoinTime;\\n\\n\\n        require(address(alliances.alliance0.alliance) != address(0), \\\"NOT_PART_OF_ANY_ALLIANCE\\\");\\n\\n        if (address(alliances.alliance1.alliance) == address(0)) {\\n            lastSlotAlliance = alliances.alliance0.alliance;\\n            lastSlotJoinTime = alliances.alliance0.joinTime;\\n            alliances.alliance0.alliance = IAlliance(address(0));\\n            alliances.alliance0.joinTime = 0;\\n        } else {\\n            if (address(alliances.alliance2.alliance) == address(0)) {\\n                lastSlotAlliance = alliances.alliance1.alliance;\\n                lastSlotJoinTime = alliances.alliance1.joinTime;\\n                alliances.alliance1.alliance = IAlliance(address(0));\\n                alliances.alliance1.joinTime = 0;\\n            } else {\\n                if (address(alliances.alliance3.alliance) == address(0)) {\\n                    lastSlotAlliance = alliances.alliance2.alliance;\\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\\n                    alliances.alliance2.alliance = IAlliance(address(0));\\n                    alliances.alliance2.joinTime = 0;\\n                } else {\\n                    lastSlotAlliance = alliances.alliance3.alliance;\\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\\n                    alliances.alliance3.alliance = IAlliance(address(0));\\n                    alliances.alliance3.joinTime = 0;\\n                }\\n            }\\n        }\\n\\n\\n        if (alliance != lastSlotAlliance) {\\n            if (alliances.alliance0.alliance == alliance) {\\n                alliances.alliance0.alliance = lastSlotAlliance;\\n                alliances.alliance0.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance1.alliance == alliance) {\\n                alliances.alliance1.alliance =lastSlotAlliance;\\n                alliances.alliance1.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance2.alliance == alliance) {\\n                alliances.alliance2.alliance =lastSlotAlliance;\\n                alliances.alliance2.joinTime = lastSlotJoinTime;\\n            } else {\\n                revert(\\\"NOT_PART_OF_THE_ALLIANCE\\\");\\n            }\\n        }\\n\\n\\n        emit AllianceLink(alliance, player, false);\\n    }\\n\\n\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n}\\n\",\"keccak256\":\"0x8270121ba959d0424cef4d25e8fc95566c0cf1cba661196094fad24d19d096cc\",\"license\":\"AGPL-1.0\"},\"src/Alliances/BasicAlliance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-1.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../AllianceRegistry.sol\\\";\\n// import \\\"../Interfaces/IAlliance.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\ncontract BasicAlliance {\\n\\n    bool internal _original;\\n    AllianceRegistry internal immutable _allianceRegistry;\\n    address public admin;\\n\\n\\n    // constructor(AllianceRegistry allianceRegistry, AllianceRegistry.PlayerSubmission[] memory playerSubmissions) {\\n    //     _allianceRegistry = allianceRegistry;\\n    //     _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\\n    // }\\n\\n    constructor(AllianceRegistry allianceRegistry) {\\n        _allianceRegistry = allianceRegistry;\\n        _original = true;\\n        admin = address(1); // lock it\\n    }\\n\\n    function setAdminAndAddMembers(address newAdmin, AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) public {\\n        address currentAdmin = admin;\\n        require(currentAdmin == address(0) || msg.sender == currentAdmin, \\\"NOT_ALLOWED\\\");\\n        admin = newAdmin;\\n        if (playerSubmissions.length > 0) {\\n            _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\\n        }\\n    }\\n\\n    function addMembers(AllianceRegistry.PlayerSubmission[] calldata playerSubmissions) external {\\n        require(msg.sender == admin, \\\"NOT_ALLOWED\\\");\\n        _allianceRegistry.addMultiplePlayersToAlliance(playerSubmissions);\\n    }\\n\\n    function instantiate(address initialAdmin, AllianceRegistry.PlayerSubmission[] calldata playerSubmissions, bytes32 salt) external {\\n        require(_original, \\\"CANNOT_INSTANTIATE_FROM_CLONES\\\");\\n        address newAlliance = Clones.cloneDeterministic(address(this), keccak256(abi.encodePacked(salt, msg.sender)));\\n        BasicAlliance(newAlliance).setAdminAndAddMembers(initialAdmin, playerSubmissions);\\n    }\\n\\n    function getAddress(bytes32 salt) external view returns(address) {\\n        require(_original, \\\"CANNOT_INSTANTIATE_FROM_CLONES\\\");\\n        return Clones.predictDeterministicAddress(address(this), keccak256(abi.encodePacked(salt, msg.sender)), address(this));\\n    }\\n\\n\\n    // function requestToJoin(address player, bytes calldata data) external view returns (bool) {\\n    //     if (player == _initialMember) {\\n    //         return true;\\n    //     } else {\\n    //         bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", \\\"Add \\\", ));\\n    //         address signer = digest.recover(signature);\\n    //         require(_outerspace.allianceJoinTime(signer, this), \\\"ONLY_ALLIANCE_MEMBER_CAN_INVITE\\\");\\n    //     }\\n    // }\\n\\n    // function playerHasLeft(address player) external {\\n\\n    // }\\n}\\n\",\"keccak256\":\"0x903f79b02765316bd677d66336052f3c45bc10c4ae863fba836aa43e36ab1f9a\",\"license\":\"AGPL-1.0\"},\"src/Interfaces/IAlliance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-1.0\\n\\npragma solidity 0.8.9;\\n\\ninterface IAlliance {\\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\\n\\n    function playerHasLeft(address player) external;\\n}\\n\\n\",\"keccak256\":\"0xac01ced7552f64f7fe9c4e5e5a4517a4a57473e72c76ecb784df9bc288445703\",\"license\":\"AGPL-1.0\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610a32380380610a3283398101604081905261002f91610054565b6001600160a01b0316608052600080546001600160a81b031916610101179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b60805161098c6100a660003960008181610182015261050a015261098c6000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80636ca1d0ed116100505780636ca1d0ed146100b0578063f851a440146100c3578063fc4c03b4146100db57600080fd5b80630b7465e41461006c57806321f8a72114610081575b600080fd5b61007f61007a36600461067d565b6100ee565b005b61009461008f3660046106bf565b6101ef565b6040516001600160a01b03909116815260200160405180910390f35b61007f6100be3660046106f4565b610305565b6000546100949061010090046001600160a01b031681565b61007f6100e936600461074e565b61042b565b60005461010090046001600160a01b031633146101525760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c4c4f57454400000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6040517f8efb75c30000000000000000000000000000000000000000000000000000000081526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638efb75c3906101b9908590859060040161090e565b600060405180830381600087803b1580156101d357600080fd5b505af11580156101e7573d6000803e3d6000fd5b505050505050565b6000805460ff166102425760405162461bcd60e51b815260206004820152601e60248201527f43414e4e4f545f494e5354414e54494154455f46524f4d5f434c4f4e455300006044820152606401610149565b6102ff30833360405160200161027492919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b60405160208183030381529060405280519060200120306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b92915050565b60005460ff166103575760405162461bcd60e51b815260206004820152601e60248201527f43414e4e4f545f494e5354414e54494154455f46524f4d5f434c4f4e455300006044820152606401610149565b60006103a630833360405160200161038b92919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b6040516020818303038152906040528051906020012061057a565b6040517ffc4c03b40000000000000000000000000000000000000000000000000000000081529091506001600160a01b0382169063fc4c03b4906103f29088908890889060040161092a565b600060405180830381600087803b15801561040c57600080fd5b505af1158015610420573d6000803e3d6000fd5b505050505050505050565b60005461010090046001600160a01b03168015806104515750336001600160a01b038216145b61049d5760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610149565b600080547fffffffffffffffffffffff0000000000000000000000000000000000000000ff166101006001600160a01b038716021790558115610574576040517f8efb75c30000000000000000000000000000000000000000000000000000000081526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638efb75c390610541908690869060040161090e565b600060405180830381600087803b15801561055b57600080fd5b505af115801561056f573d6000803e3d6000fd5b505050505b50505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f59150506001600160a01b0381166102ff5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152606401610149565b60008083601f84011261064357600080fd5b50813567ffffffffffffffff81111561065b57600080fd5b6020830191508360208260051b850101111561067657600080fd5b9250929050565b6000806020838503121561069057600080fd5b823567ffffffffffffffff8111156106a757600080fd5b6106b385828601610631565b90969095509350505050565b6000602082840312156106d157600080fd5b5035919050565b80356001600160a01b03811681146106ef57600080fd5b919050565b6000806000806060858703121561070a57600080fd5b610713856106d8565b9350602085013567ffffffffffffffff81111561072f57600080fd5b61073b87828801610631565b9598909750949560400135949350505050565b60008060006040848603121561076357600080fd5b61076c846106d8565b9250602084013567ffffffffffffffff81111561078857600080fd5b61079486828701610631565b9497909650939450505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b81835260006020808501808196508560051b810191508460005b8781101561090157828403895281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa188360301811261084357600080fd5b870160606001600160a01b03610858836106d8565b1686528682013563ffffffff811680821461087257600080fd5b8789015250604082810135368490037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe10181126108ae57600080fd5b8301803567ffffffffffffffff8111156108c757600080fd5b8036038513156108d657600080fd5b83838a01526108ea848a01828c85016107a1565b9d8a019d9850505093870193505050600101610804565b5091979650505050505050565b6020815260006109226020830184866107ea565b949350505050565b6001600160a01b038416815260406020820152600061094d6040830184866107ea565b9594505050505056fea26469706673582212203a6bae0d2211e05dc358abdb7d148a23f934dca8c9725ee64df7ca0bf5359f1d64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c80636ca1d0ed116100505780636ca1d0ed146100b0578063f851a440146100c3578063fc4c03b4146100db57600080fd5b80630b7465e41461006c57806321f8a72114610081575b600080fd5b61007f61007a36600461067d565b6100ee565b005b61009461008f3660046106bf565b6101ef565b6040516001600160a01b03909116815260200160405180910390f35b61007f6100be3660046106f4565b610305565b6000546100949061010090046001600160a01b031681565b61007f6100e936600461074e565b61042b565b60005461010090046001600160a01b031633146101525760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c4c4f57454400000000000000000000000000000000000000000060448201526064015b60405180910390fd5b6040517f8efb75c30000000000000000000000000000000000000000000000000000000081526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638efb75c3906101b9908590859060040161090e565b600060405180830381600087803b1580156101d357600080fd5b505af11580156101e7573d6000803e3d6000fd5b505050505050565b6000805460ff166102425760405162461bcd60e51b815260206004820152601e60248201527f43414e4e4f545f494e5354414e54494154455f46524f4d5f434c4f4e455300006044820152606401610149565b6102ff30833360405160200161027492919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b60405160208183030381529060405280519060200120306040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000008152606093841b60148201527f5af43d82803e903d91602b57fd5bf3ff000000000000000000000000000000006028820152921b6038830152604c8201526037808220606c830152605591012090565b92915050565b60005460ff166103575760405162461bcd60e51b815260206004820152601e60248201527f43414e4e4f545f494e5354414e54494154455f46524f4d5f434c4f4e455300006044820152606401610149565b60006103a630833360405160200161038b92919091825260601b6bffffffffffffffffffffffff1916602082015260340190565b6040516020818303038152906040528051906020012061057a565b6040517ffc4c03b40000000000000000000000000000000000000000000000000000000081529091506001600160a01b0382169063fc4c03b4906103f29088908890889060040161092a565b600060405180830381600087803b15801561040c57600080fd5b505af1158015610420573d6000803e3d6000fd5b505050505050505050565b60005461010090046001600160a01b03168015806104515750336001600160a01b038216145b61049d5760405162461bcd60e51b815260206004820152600b60248201527f4e4f545f414c4c4f5745440000000000000000000000000000000000000000006044820152606401610149565b600080547fffffffffffffffffffffff0000000000000000000000000000000000000000ff166101006001600160a01b038716021790558115610574576040517f8efb75c30000000000000000000000000000000000000000000000000000000081526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690638efb75c390610541908690869060040161090e565b600060405180830381600087803b15801561055b57600080fd5b505af115801561056f573d6000803e3d6000fd5b505050505b50505050565b60006040517f3d602d80600a3d3981f3363d3d373d3d3d363d7300000000000000000000000081528360601b60148201527f5af43d82803e903d91602b57fd5bf300000000000000000000000000000000006028820152826037826000f59150506001600160a01b0381166102ff5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c65640000000000000000006044820152606401610149565b60008083601f84011261064357600080fd5b50813567ffffffffffffffff81111561065b57600080fd5b6020830191508360208260051b850101111561067657600080fd5b9250929050565b6000806020838503121561069057600080fd5b823567ffffffffffffffff8111156106a757600080fd5b6106b385828601610631565b90969095509350505050565b6000602082840312156106d157600080fd5b5035919050565b80356001600160a01b03811681146106ef57600080fd5b919050565b6000806000806060858703121561070a57600080fd5b610713856106d8565b9350602085013567ffffffffffffffff81111561072f57600080fd5b61073b87828801610631565b9598909750949560400135949350505050565b60008060006040848603121561076357600080fd5b61076c846106d8565b9250602084013567ffffffffffffffff81111561078857600080fd5b61079486828701610631565b9497909650939450505050565b8183528181602085013750600060208284010152600060207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f840116840101905092915050565b81835260006020808501808196508560051b810191508460005b8781101561090157828403895281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa188360301811261084357600080fd5b870160606001600160a01b03610858836106d8565b1686528682013563ffffffff811680821461087257600080fd5b8789015250604082810135368490037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe10181126108ae57600080fd5b8301803567ffffffffffffffff8111156108c757600080fd5b8036038513156108d657600080fd5b83838a01526108ea848a01828c85016107a1565b9d8a019d9850505093870193505050600101610804565b5091979650505050505050565b6020815260006109226020830184866107ea565b949350505050565b6001600160a01b038416815260406020820152600061094d6040830184866107ea565b9594505050505056fea26469706673582212203a6bae0d2211e05dc358abdb7d148a23f934dca8c9725ee64df7ca0bf5359f1d64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 10776,
        "contract": "src/Alliances/BasicAlliance.sol:BasicAlliance",
        "label": "_original",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 10781,
        "contract": "src/Alliances/BasicAlliance.sol:BasicAlliance",
        "label": "admin",
        "offset": 1,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      }
    }
  }
}