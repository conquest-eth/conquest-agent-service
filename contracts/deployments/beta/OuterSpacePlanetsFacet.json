{
  "address": "0xAdb7FBD47Dd64C2e95359Da224cE15EF4B301e5A",
  "abi": [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IERC20",
              "name": "stakingToken",
              "type": "address"
            },
            {
              "internalType": "contract AllianceRegistry",
              "name": "allianceRegistry",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "genesis",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "resolveWindow",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timePerDistance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "exitDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint32",
              "name": "acquireNumSpaceships",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "productionSpeedUp",
              "type": "uint32"
            },
            {
              "internalType": "uint256",
              "name": "frontrunningDelay",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "productionCapAsDuration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "upkeepProductionDecreaseRatePer10000th",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fleetSizeFactor6",
              "type": "uint256"
            }
          ],
          "internalType": "struct OuterSpaceFacetBase.Config",
          "name": "config",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        }
      ],
      "name": "ExitComplete",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "destinationOwner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destination",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "gift",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "fleetLoss",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "planetLoss",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "inFlightFleetLoss",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "inFlightPlanetLoss",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "won",
          "type": "bool"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumspaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "accumulatedDefenseAdded",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "accumulatedAttackAdded",
          "type": "uint32"
        }
      ],
      "name": "FleetArrived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetSender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "fleetOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "from",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "quantity",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumSpaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        }
      ],
      "name": "FleetSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "minX",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "maxX",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "minY",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "maxY",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "genesis",
          "type": "bytes32"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "PlanetExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "PlanetReset",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "acquirer",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "numSpaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "travelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "overflow",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stake",
          "type": "uint256"
        }
      ],
      "name": "PlanetStake",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "giver",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rewardId",
          "type": "uint256"
        }
      ],
      "name": "RewardSetup",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "rewardId",
          "type": "uint256"
        }
      ],
      "name": "RewardToWithdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newStake",
          "type": "uint256"
        }
      ],
      "name": "StakeToWithdraw",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "origin",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "fleet",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newNumspaceships",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "int40",
          "name": "newTravelingUpkeep",
          "type": "int40"
        },
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "newOverflow",
          "type": "uint32"
        }
      ],
      "name": "TravelingUpkeepReductionFromDestruction",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "getPlanet",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint40",
              "name": "ownershipStartTime",
              "type": "uint40"
            },
            {
              "internalType": "uint40",
              "name": "exitStartTime",
              "type": "uint40"
            },
            {
              "internalType": "uint32",
              "name": "numSpaceships",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "overflow",
              "type": "uint32"
            },
            {
              "internalType": "uint40",
              "name": "lastUpdated",
              "type": "uint40"
            },
            {
              "internalType": "bool",
              "name": "active",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "reward",
              "type": "uint256"
            }
          ],
          "internalType": "struct ImportingOuterSpaceTypes.ExternalPlanet",
          "name": "state",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "int8",
              "name": "subX",
              "type": "int8"
            },
            {
              "internalType": "int8",
              "name": "subY",
              "type": "int8"
            },
            {
              "internalType": "uint16",
              "name": "stake",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "production",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "attack",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "defense",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "speed",
              "type": "uint16"
            },
            {
              "internalType": "uint16",
              "name": "natives",
              "type": "uint16"
            }
          ],
          "internalType": "struct ImportingOuterSpaceTypes.PlanetStats",
          "name": "stats",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "getPlanetState",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint40",
              "name": "ownershipStartTime",
              "type": "uint40"
            },
            {
              "internalType": "uint40",
              "name": "exitStartTime",
              "type": "uint40"
            },
            {
              "internalType": "uint32",
              "name": "numSpaceships",
              "type": "uint32"
            },
            {
              "internalType": "uint40",
              "name": "lastUpdated",
              "type": "uint40"
            },
            {
              "internalType": "int40",
              "name": "travelingUpkeep",
              "type": "int40"
            },
            {
              "internalType": "uint32",
              "name": "overflow",
              "type": "uint32"
            }
          ],
          "internalType": "struct ImportingOuterSpaceTypes.Planet",
          "name": "state",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "ownerAndOwnershipStartTimeOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint40",
          "name": "ownershipStartTime",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "currentOwner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IApprovalReceiver",
          "name": "operator",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "setApprovalForAllIfNeededAndCall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "location",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xb064966a8288bb7f816f08615b0b28579d93cad543f888dc2b3dbabe9611b906",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xbE19B59E8C588d68f475A407C7BA5fE813AEb792",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "1368739",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2036c3cf6e8f358838ec69067b8242597c5e3df465e57bd06a2fd8011c0411d2",
    "transactionHash": "0xb064966a8288bb7f816f08615b0b28579d93cad543f888dc2b3dbabe9611b906",
    "logs": [],
    "blockNumber": 20869052,
    "cumulativeGasUsed": "2634360",
    "status": 1,
    "byzantium": true
  },
  "args": [
    {
      "stakingToken": "0xEb18a3421b24bC32DABF2e646DBD9FD827d46B1d",
      "allianceRegistry": "0x51507c1b704DEE93160A01DC56E666b7CB5A8076",
      "genesis": "0x54cfc698a2dc6796e9cf1ab3cdbcc07c54b649287b791b14c040997bdc379b34",
      "resolveWindow": 43200,
      "timePerDistance": 7200,
      "exitDuration": 259200,
      "acquireNumSpaceships": 100000,
      "productionSpeedUp": 1,
      "frontrunningDelay": 1800,
      "productionCapAsDuration": 259200,
      "upkeepProductionDecreaseRatePer10000th": 5000,
      "fleetSizeFactor6": 500000
    }
  ],
  "numDeployments": 1,
  "linkedData": {
    "genesisHash": "0x54cfc698a2dc6796e9cf1ab3cdbcc07c54b649287b791b14c040997bdc379b34",
    "resolveWindow": 43200,
    "timePerDistance": 7200,
    "exitDuration": 259200,
    "acquireNumSpaceships": 100000,
    "productionSpeedUp": 1,
    "chainGenesisHash": "",
    "frontrunningDelay": 1800,
    "productionCapAsDuration": 259200,
    "upkeepProductionDecreaseRatePer10000th": 5000,
    "fleetSizeFactor6": 500000
  },
  "solcInputHash": "54031a5456ab27c09a0d821c4b18f56f",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"contract AllianceRegistry\",\"name\":\"allianceRegistry\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"resolveWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePerDistance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exitDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"acquireNumSpaceships\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"productionSpeedUp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"frontrunningDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"productionCapAsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upkeepProductionDecreaseRatePer10000th\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fleetSizeFactor6\",\"type\":\"uint256\"}],\"internalType\":\"struct OuterSpaceFacetBase.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"ExitComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destinationOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destination\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"gift\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fleetLoss\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"planetLoss\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"inFlightFleetLoss\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"inFlightPlanetLoss\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"won\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumspaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"accumulatedDefenseAdded\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"accumulatedAttackAdded\",\"type\":\"uint32\"}],\"name\":\"FleetArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetSender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fleetOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"quantity\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumSpaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"}],\"name\":\"FleetSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minX\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxX\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minY\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maxY\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"genesis\",\"type\":\"bytes32\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"PlanetExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"PlanetReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acquirer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numSpaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"travelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"overflow\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"PlanetStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"giver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardId\",\"type\":\"uint256\"}],\"name\":\"RewardSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardId\",\"type\":\"uint256\"}],\"name\":\"RewardToWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStake\",\"type\":\"uint256\"}],\"name\":\"StakeToWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"origin\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fleet\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumspaceships\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int40\",\"name\":\"newTravelingUpkeep\",\"type\":\"int40\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newOverflow\",\"type\":\"uint32\"}],\"name\":\"TravelingUpkeepReductionFromDestruction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"getPlanet\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"ownershipStartTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"exitStartTime\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"numSpaceships\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"overflow\",\"type\":\"uint32\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdated\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"internalType\":\"struct ImportingOuterSpaceTypes.ExternalPlanet\",\"name\":\"state\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int8\",\"name\":\"subX\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"subY\",\"type\":\"int8\"},{\"internalType\":\"uint16\",\"name\":\"stake\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"production\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"attack\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"defense\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"speed\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"natives\",\"type\":\"uint16\"}],\"internalType\":\"struct ImportingOuterSpaceTypes.PlanetStats\",\"name\":\"stats\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"getPlanetState\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"ownershipStartTime\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"exitStartTime\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"numSpaceships\",\"type\":\"uint32\"},{\"internalType\":\"uint40\",\"name\":\"lastUpdated\",\"type\":\"uint40\"},{\"internalType\":\"int40\",\"name\":\"travelingUpkeep\",\"type\":\"int40\"},{\"internalType\":\"uint32\",\"name\":\"overflow\",\"type\":\"uint32\"}],\"internalType\":\"struct ImportingOuterSpaceTypes.Planet\",\"name\":\"state\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"ownerAndOwnershipStartTimeOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"ownershipStartTime\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IApprovalReceiver\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"setApprovalForAllIfNeededAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/outerspace/facets/OuterSpacePlanetsFacet.sol\":\"OuterSpacePlanetsFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xbc991a1cf357ce19480831a40792c814238a3b5458134703682abd8aa39719fb\",\"license\":\"MIT\"},\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaaceeafeeaf0d200ca3942d8bf14c1c4f787a77f79cc87c08bb668e65acdee29\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"src/alliances/AllianceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"hardhat-deploy/solc_0.8/proxy/Proxied.sol\\\";\\nimport \\\"../interfaces/IAlliance.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract AllianceRegistry is Proxied {\\n    using ECDSA for bytes32;\\n\\n    uint8 internal constant MAX_NUM_ALLIANCES = 4;\\n\\n    mapping(address => mapping(IAlliance => uint256)) internal _allianceNonces;\\n    struct AllianceRow {\\n        IAlliance alliance;\\n        uint96 joinTime;\\n    }\\n    struct Alliances {\\n        AllianceRow alliance0;\\n        AllianceRow alliance1;\\n        AllianceRow alliance2;\\n        AllianceRow alliance3;\\n    }\\n    mapping(address => Alliances) internal _alliances;\\n\\n    event AllianceLink(IAlliance indexed alliance, address indexed player, bool joining);\\n\\n    function getAllianceDataAtSlot(address player, uint8 slot)\\n        external\\n        view\\n        returns (\\n            IAlliance alliance,\\n            uint96 joinTime,\\n            uint256 nonce\\n        )\\n    {\\n        Alliances storage alliances = _alliances[player];\\n        if (slot == 0) {\\n            alliance = alliances.alliance0.alliance;\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (slot == 1) {\\n            alliance = alliances.alliance1.alliance;\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (slot == 2) {\\n            alliance = alliances.alliance2.alliance;\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (slot == 3) {\\n            alliance = alliances.alliance3.alliance;\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n\\n        nonce = _allianceNonces[player][alliance];\\n    }\\n\\n    function getAllianceData(address player, IAlliance alliance)\\n        external\\n        view\\n        returns (uint96 joinTime, uint256 nonce)\\n    {\\n        nonce = _allianceNonces[player][alliance];\\n\\n        Alliances storage alliances = _alliances[player];\\n        if (alliances.alliance0.alliance == alliance) {\\n            joinTime = alliances.alliance0.joinTime;\\n        } else if (alliances.alliance1.alliance == alliance) {\\n            joinTime = alliances.alliance1.joinTime;\\n        } else if (alliances.alliance2.alliance == alliance) {\\n            joinTime = alliances.alliance2.joinTime;\\n        } else if (alliances.alliance3.alliance == alliance) {\\n            joinTime = alliances.alliance3.joinTime;\\n        }\\n    }\\n\\n    function havePlayersAnAllianceInCommon(\\n        address player1,\\n        address player2,\\n        uint256 timestamp\\n    ) external view returns (IAlliance alliance, uint96 joinTime) {\\n        Alliances storage p1Alliances = _alliances[player1];\\n        Alliances storage p2Alliances = _alliances[player2];\\n\\n        AllianceRow[4] memory player1Alliances;\\n        AllianceRow[4] memory player2Alliances;\\n        uint256 num1 = 0;\\n        uint256 num2 = 0;\\n\\n        for (uint256 i = 0; i < 4; i++) {\\n            if (i == num1) {\\n                AllianceRow memory allianceRow;\\n                if (i == 0) {\\n                    allianceRow = p1Alliances.alliance0;\\n                } else if (i == 1) {\\n                    allianceRow = p1Alliances.alliance1;\\n                } else if (i == 2) {\\n                    allianceRow = p1Alliances.alliance2;\\n                } else if (i == 3) {\\n                    allianceRow = p1Alliances.alliance3;\\n                }\\n                if (address(allianceRow.alliance) == address(0)) {\\n                    // console.log(\\\"p1 exhausted\\\");\\n                    return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                }\\n                player1Alliances[num1++] = allianceRow;\\n            }\\n            for (uint256 j = 0; j < 4; j++) {\\n                if (j == num2) {\\n                    AllianceRow memory allianceRow;\\n                    if (j == 0) {\\n                        allianceRow = p2Alliances.alliance0;\\n                    } else if (j == 1) {\\n                        allianceRow = p2Alliances.alliance1;\\n                    } else if (j == 2) {\\n                        allianceRow = p2Alliances.alliance2;\\n                    } else if (j == 3) {\\n                        allianceRow = p2Alliances.alliance3;\\n                    }\\n                    if (address(allianceRow.alliance) == address(0)) {\\n                        // console.log(\\\"p2 exhausted\\\");\\n                        // return (alliance, joinTime); // the alliance leave ensure that there is no gap // TODO\\n                        break;\\n                    }\\n                    player2Alliances[num2++] = allianceRow;\\n                }\\n\\n                if (player1Alliances[i].alliance == player2Alliances[j].alliance) {\\n                    if (player1Alliances[i].joinTime >= player2Alliances[j].joinTime) {\\n                        if (player1Alliances[i].joinTime < timestamp) {\\n                            return (player1Alliances[i].alliance, player1Alliances[i].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player1Alliances[i].alliance;\\n                            joinTime = player1Alliances[i].joinTime;\\n                        }\\n                    } else {\\n                        if (player2Alliances[j].joinTime < timestamp) {\\n                            return (player2Alliances[j].alliance, player2Alliances[j].joinTime);\\n                        } else {\\n                            // TODO check greater ?\\n                            alliance = player2Alliances[j].alliance;\\n                            joinTime = player2Alliances[j].joinTime;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // console.log(address(alliance));\\n        // console.log(joinTime);\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM PLAYER\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function joinAlliance(IAlliance alliance, bytes calldata data) external returns (bool joined) {\\n        Alliances storage alliances = _alliances[msg.sender];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            slot++;\\n        }\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n        joined = alliance.requestToJoin(msg.sender, data);\\n        if (joined) {\\n            if (slot == 0) {\\n                alliances.alliance0.alliance = alliance;\\n                alliances.alliance0.joinTime = uint96(block.timestamp);\\n            } else if (slot == 1) {\\n                alliances.alliance1.alliance = alliance;\\n                alliances.alliance1.joinTime = uint96(block.timestamp);\\n            } else if (slot == 2) {\\n                alliances.alliance2.alliance = alliance;\\n                alliances.alliance2.joinTime = uint96(block.timestamp);\\n            } else if (slot == 3) {\\n                alliances.alliance3.alliance = alliance;\\n                alliances.alliance3.joinTime = uint96(block.timestamp);\\n            }\\n\\n            emit AllianceLink(alliance, msg.sender, true);\\n        }\\n    }\\n\\n    function leaveAlliance(IAlliance alliance) external {\\n        _leaveAlliance(msg.sender, alliance);\\n        try alliance.playerHasLeft(msg.sender) {} catch {}\\n        // TODO ensure callback not failed due to low gas (1/64 rule)\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // FROM ALLIANCE\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) external {\\n        _addPlayerToAlliance(player, nonce, signature);\\n    }\\n\\n    struct PlayerSubmission {\\n        address addr;\\n        uint32 nonce;\\n        bytes signature;\\n    }\\n\\n    function addMultiplePlayersToAlliance(PlayerSubmission[] calldata playerSubmissions) external {\\n        for (uint256 i = 0; i < playerSubmissions.length; i++) {\\n            _addPlayerToAlliance(playerSubmissions[i].addr, playerSubmissions[i].nonce, playerSubmissions[i].signature);\\n        }\\n    }\\n\\n    function ejectPlayerFromAlliance(address player) external {\\n        _leaveAlliance(player, IAlliance(msg.sender));\\n    }\\n\\n    // -----------------------------------------------------------------------------------------------------\\n    // INTERNAL\\n    // -----------------------------------------------------------------------------------------------------\\n\\n    function _addPlayerToAlliance(\\n        address player,\\n        uint32 nonce,\\n        bytes calldata signature\\n    ) internal {\\n        IAlliance alliance = IAlliance(msg.sender);\\n\\n        Alliances storage alliances = _alliances[player];\\n        uint256 slot = 0;\\n        if (address(alliances.alliance0.alliance) != address(0)) {\\n            require(alliances.alliance0.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance1.alliance) != address(0)) {\\n            require(alliances.alliance1.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        if (address(alliances.alliance2.alliance) != address(0)) {\\n            require(alliances.alliance2.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n            slot++;\\n        }\\n        require(alliances.alliance3.alliance != alliance, \\\"ALREADY_JOINED\\\");\\n        require(address(alliances.alliance3.alliance) == address(0), \\\"MAX_NUM_ALLIANCES_REACHED\\\");\\n\\n        uint256 currentNonce = _allianceNonces[player][alliance];\\n        require(currentNonce == nonce, \\\"INVALID_NONCE\\\");\\n\\n        bytes memory message;\\n        if (nonce == 0) {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n56\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n        } else {\\n            message = abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n76\\\",\\n                \\\"Join Alliance 0x0000000000000000000000000000000000000000 (nonce:          0)\\\"\\n            );\\n            _writeUintAsHex(message, 28 + 55, uint160(msg.sender));\\n            _writeUintAsDecimal(message, 28 + 74, nonce);\\n        }\\n\\n        // console.log(string(message));\\n\\n        bytes32 digest = keccak256(message);\\n\\n        address signer = digest.recover(signature);\\n        require(player == signer, \\\"INVALID_SIGNATURE\\\");\\n\\n        if (slot == 0) {\\n            alliances.alliance0.alliance = alliance;\\n            alliances.alliance0.joinTime = uint96(block.timestamp);\\n        } else if (slot == 1) {\\n            alliances.alliance1.alliance = alliance;\\n            alliances.alliance1.joinTime = uint96(block.timestamp);\\n        } else if (slot == 2) {\\n            alliances.alliance2.alliance = alliance;\\n            alliances.alliance2.joinTime = uint96(block.timestamp);\\n        } else if (slot == 3) {\\n            alliances.alliance3.alliance = alliance;\\n            alliances.alliance3.joinTime = uint96(block.timestamp);\\n        }\\n        _allianceNonces[player][alliance] = nonce + 1;\\n\\n        emit AllianceLink(alliance, player, true);\\n    }\\n\\n    bytes internal constant hexAlphabet = \\\"0123456789abcdef\\\";\\n    bytes internal constant decimalAlphabet = \\\"0123456789\\\";\\n\\n    function _writeUintAsHex(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(hexAlphabet[num % 16]);\\n            num /= 16;\\n        }\\n    }\\n\\n    function _writeUintAsDecimal(\\n        bytes memory data,\\n        uint256 endPos,\\n        uint256 num\\n    ) internal pure {\\n        while (num != 0) {\\n            data[endPos--] = bytes1(decimalAlphabet[num % 10]);\\n            num /= 10;\\n        }\\n    }\\n\\n    function _leaveAlliance(address player, IAlliance alliance) internal {\\n        Alliances storage alliances = _alliances[msg.sender];\\n\\n        IAlliance lastSlotAlliance;\\n        uint96 lastSlotJoinTime;\\n\\n        require(address(alliances.alliance0.alliance) != address(0), \\\"NOT_PART_OF_ANY_ALLIANCE\\\");\\n\\n        if (address(alliances.alliance1.alliance) == address(0)) {\\n            lastSlotAlliance = alliances.alliance0.alliance;\\n            lastSlotJoinTime = alliances.alliance0.joinTime;\\n            alliances.alliance0.alliance = IAlliance(address(0));\\n            alliances.alliance0.joinTime = 0;\\n        } else {\\n            if (address(alliances.alliance2.alliance) == address(0)) {\\n                lastSlotAlliance = alliances.alliance1.alliance;\\n                lastSlotJoinTime = alliances.alliance1.joinTime;\\n                alliances.alliance1.alliance = IAlliance(address(0));\\n                alliances.alliance1.joinTime = 0;\\n            } else {\\n                if (address(alliances.alliance3.alliance) == address(0)) {\\n                    lastSlotAlliance = alliances.alliance2.alliance;\\n                    lastSlotJoinTime = alliances.alliance2.joinTime;\\n                    alliances.alliance2.alliance = IAlliance(address(0));\\n                    alliances.alliance2.joinTime = 0;\\n                } else {\\n                    lastSlotAlliance = alliances.alliance3.alliance;\\n                    lastSlotJoinTime = alliances.alliance3.joinTime;\\n                    alliances.alliance3.alliance = IAlliance(address(0));\\n                    alliances.alliance3.joinTime = 0;\\n                }\\n            }\\n        }\\n\\n        if (alliance != lastSlotAlliance) {\\n            if (alliances.alliance0.alliance == alliance) {\\n                alliances.alliance0.alliance = lastSlotAlliance;\\n                alliances.alliance0.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance1.alliance == alliance) {\\n                alliances.alliance1.alliance = lastSlotAlliance;\\n                alliances.alliance1.joinTime = lastSlotJoinTime;\\n            } else if (alliances.alliance2.alliance == alliance) {\\n                alliances.alliance2.alliance = lastSlotAlliance;\\n                alliances.alliance2.joinTime = lastSlotJoinTime;\\n            } else {\\n                revert(\\\"NOT_PART_OF_THE_ALLIANCE\\\");\\n            }\\n        }\\n\\n        emit AllianceLink(alliance, player, false);\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n}\\n\",\"keccak256\":\"0x500fa21ebe8487898b468831025fd837c663803bcdebccb6d5ad19150922371d\",\"license\":\"AGPL-3.0\"},\"src/interfaces/IAlliance.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\ninterface IAlliance {\\n    function requestToJoin(address player, bytes calldata data) external returns (bool);\\n\\n    function playerHasLeft(address player) external;\\n}\\n\",\"keccak256\":\"0x56331cf35f0c52161d22a1094809e4e55b6be6dff3f7c18a3070b325e1afced8\",\"license\":\"AGPL-3.0\"},\"src/libraries/Extraction.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\n// TODO remove\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary Extraction {\\n    function value(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 size\\n    ) internal pure returns (uint256) {\\n        return uint256((data >> leastSignificantBit)) % 2**size;\\n    }\\n\\n    function value8Mod(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        uint8 mod\\n    ) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % mod);\\n    }\\n\\n    function value8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\\n        return uint8(uint256((data >> leastSignificantBit)) % 2**8);\\n    }\\n\\n    // 1+1+2+3+4+6+7+8+8+7+6+4+3+2+1+1 // aproximation of normal distribution with mean=7.5 and standard deviation=3 for 16 values\\n    bytes32 constant n_m7_5_sd3 = 0x01223334444555555666666677777777888888889999999AAAAAABBBBCCCDDEF;\\n\\n    function normal8(bytes32 data, uint8 leastSignificantBit) internal pure returns (uint8) {\\n        uint8 index = value8Mod(data, leastSignificantBit, 64);\\n        uint8 first = index / 2;\\n        uint8 second = index % 2;\\n        uint8 slot = uint8(n_m7_5_sd3[first]);\\n        if (second == 0) {\\n            return slot >> 4;\\n        } else {\\n            return slot % 16;\\n        }\\n    }\\n\\n    function normal16(\\n        bytes32 data,\\n        uint8 leastSignificantBit,\\n        bytes32 selection\\n    ) internal pure returns (uint16) {\\n        uint8 index = normal8(data, leastSignificantBit);\\n        return uint16(uint8(selection[index * 2])) * 2**8 + uint16(uint8(selection[index * 2 + 1]));\\n    }\\n}\\n\",\"keccak256\":\"0x4264ffbd03c4be49f317ed019abbe0594051606df36e7a707d74456b49130c86\",\"license\":\"AGPL-3.0\"},\"src/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.9;\\n\\nlibrary Math {\\n    function mul(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require(b == 0 || a == 0 || ((c = a * b) / b) == a, overflowError);\\n    }\\n\\n    function add(\\n        uint256 a,\\n        uint256 b,\\n        string memory overflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a + b) >= a, overflowError);\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory underflowError\\n    ) internal pure returns (uint256 c) {\\n        require((c = a - b) <= a, underflowError);\\n    }\\n\\n    function mul18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, b18, overflowError) / 10**18;\\n    }\\n\\n    function div18(\\n        uint256 a18,\\n        uint256 b18,\\n        string memory overflowError\\n    ) internal pure returns (uint256) {\\n        return mul(a18, 10**18, overflowError) / b18;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function smin(int256 a, int256 b) internal pure returns (int256) {\\n        return a <= b ? a : b;\\n    }\\n\\n    function smax(int256 a, int256 b) internal pure returns (int256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    function sqrt(uint256 a) internal pure returns (uint256 c) {\\n        uint256 tmp = (a + 1) / 2;\\n        c = a;\\n        while (tmp < c) {\\n            c = tmp;\\n            tmp = ((a / tmp) + tmp) / 2;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa2d7dff3199295e64e0b6361f8533fb093bfdbd6a60154cadd1d4f6619281260\",\"license\":\"AGPL-3.0\"},\"src/outerspace/base/ImportingOuterSpaceConstants.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ncontract ImportingOuterSpaceConstants {\\n    uint256 internal constant DECIMALS_18 = 1e18;\\n    uint32 internal constant ACTIVE_MASK = 2**31;\\n    int256 internal constant UINT32_MAX = 2**32 - 1;\\n    int256 internal constant UINT32_MIN = -2147483648;\\n\\n    int256 internal constant EXPANSION = 8;\\n    uint32 internal constant INITIAL_SPACE = 16;\\n    uint256 internal constant GIFT_TAX_PER_10000 = 2500;\\n\\n    uint256 internal constant COMBAT_RULE_SWITCH_TIME = 1620144000; // Tuesday, 4 May 2021 16:00:00 GMT\\n}\\n\",\"keccak256\":\"0xdfd9d8ccaaa0a4485afaaa12d9f44f89eb2bd4bf95e6687ba3efd215e9ed17a4\",\"license\":\"AGPL-3.0\"},\"src/outerspace/base/UsingOuterSpaceDataLayout.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\n\\ncontract UsingOuterSpaceDataLayout is ImportingOuterSpaceTypes {\\n    mapping(uint256 => Planet) internal _planets;\\n    mapping(uint256 => Fleet) internal _fleets;\\n\\n    mapping(address => uint256) internal _stakeReadyToBeWithdrawn;\\n\\n    mapping(address => mapping(address => bool)) internal _operators;\\n\\n    // TODO make it namespaces per user, currently it is possible (though unlikely) for 2 users to share a slot if one attack another and quickly send away spaceships\\n    mapping(uint256 => mapping(uint256 => InFlight)) internal _inFlight;\\n\\n    Discovered internal _discovered;\\n    // rewards\\n    mapping(address => uint256) internal _prevRewardIds;\\n    mapping(uint256 => uint256) internal _rewards;\\n    mapping(address => mapping(uint256 => bool)) internal _rewardsToWithdraw;\\n\\n    // This adds 20,000 gas to all resolution\\n    mapping(uint256 => mapping(address => mapping(uint256 => AccumulatedAttack))) internal _attacks;\\n\\n    // remove\\n    // mapping(address => Account) internal _accounts;\\n}\\n\",\"keccak256\":\"0x101bd8f6d39a9f594f377ae36bbe007604b04a06af4737766ec2745fdcbf91d1\",\"license\":\"AGPL-3.0\"},\"src/outerspace/events/ImportingOuterSpaceEvents.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface ImportingOuterSpaceEvents {\\n    event PlanetStake(\\n        address indexed acquirer,\\n        uint256 indexed location,\\n        uint32 numSpaceships,\\n        int40 travelingUpkeep,\\n        uint32 overflow,\\n        uint256 stake\\n    );\\n    event FleetSent(\\n        address indexed fleetSender,\\n        address indexed fleetOwner,\\n        uint256 indexed from,\\n        address operator,\\n        uint256 fleet,\\n        uint32 quantity,\\n        uint32 newNumSpaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event FleetArrived(\\n        uint256 indexed fleet,\\n        address indexed fleetOwner,\\n        address indexed destinationOwner,\\n        uint256 destination,\\n        bool gift,\\n        uint32 fleetLoss,\\n        uint32 planetLoss,\\n        uint32 inFlightFleetLoss,\\n        uint32 inFlightPlanetLoss,\\n        bool won,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow,\\n        uint32 accumulatedDefenseAdded,\\n        uint32 accumulatedAttackAdded\\n    );\\n\\n    event TravelingUpkeepReductionFromDestruction(\\n        uint256 indexed origin,\\n        uint256 indexed fleet,\\n        uint32 newNumspaceships,\\n        int40 newTravelingUpkeep,\\n        uint32 newOverflow\\n    );\\n\\n    event PlanetReset(uint256 indexed location);\\n\\n    event PlanetExit(address indexed owner, uint256 indexed location);\\n\\n    event ExitComplete(address indexed owner, uint256 indexed location, uint256 stake);\\n\\n    event RewardSetup(uint256 indexed location, address indexed giver, uint256 rewardId);\\n    event RewardToWithdraw(address indexed owner, uint256 indexed location, uint256 indexed rewardId);\\n\\n    event StakeToWithdraw(address indexed owner, uint256 newStake);\\n\\n    event Initialized(uint32 minX, uint32 maxX, uint32 minY, uint32 maxY, bytes32 genesis);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    // TODO use it\\n    event Transfer(address indexed from, address indexed to, uint256 indexed location);\\n}\\n\",\"keccak256\":\"0xe7b8bc304fb1874e04f3b845620d7d81304d5554b375d2f30e51f3289149a20e\",\"license\":\"AGPL-3.0\"},\"src/outerspace/facets/OuterSpaceFacetBase.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../base/ImportingOuterSpaceConstants.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\nimport \\\"../base/UsingOuterSpaceDataLayout.sol\\\";\\n\\nimport \\\"../../libraries/Extraction.sol\\\";\\nimport \\\"../../libraries/Math.sol\\\";\\n\\nimport \\\"../../interfaces/IAlliance.sol\\\";\\nimport \\\"../../alliances/AllianceRegistry.sol\\\";\\n\\n// TODO Remove\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract OuterSpaceFacetBase is\\n    ImportingOuterSpaceTypes,\\n    ImportingOuterSpaceConstants,\\n    ImportingOuterSpaceEvents,\\n    UsingOuterSpaceDataLayout\\n{\\n    using Extraction for bytes32;\\n\\n    IERC20 internal immutable _stakingToken;\\n    AllianceRegistry internal immutable _allianceRegistry;\\n    bytes32 internal immutable _genesis;\\n    uint256 internal immutable _resolveWindow;\\n    uint256 internal immutable _timePerDistance;\\n    uint256 internal immutable _exitDuration;\\n    uint32 internal immutable _acquireNumSpaceships;\\n    uint32 internal immutable _productionSpeedUp;\\n    uint256 internal immutable _frontrunningDelay;\\n    uint256 internal immutable _productionCapAsDuration;\\n    uint256 internal immutable _upkeepProductionDecreaseRatePer10000th;\\n    uint256 internal immutable _fleetSizeFactor6;\\n\\n    struct Config {\\n        IERC20 stakingToken;\\n        AllianceRegistry allianceRegistry;\\n        bytes32 genesis;\\n        uint256 resolveWindow;\\n        uint256 timePerDistance;\\n        uint256 exitDuration;\\n        uint32 acquireNumSpaceships;\\n        uint32 productionSpeedUp;\\n        uint256 frontrunningDelay;\\n        uint256 productionCapAsDuration;\\n        uint256 upkeepProductionDecreaseRatePer10000th;\\n        uint256 fleetSizeFactor6;\\n    }\\n\\n    constructor(Config memory config) {\\n        uint32 t = uint32(config.timePerDistance) / 4; // the coordinates space is 4 times bigger\\n        require(t * 4 == config.timePerDistance, \\\"TIME_PER_DIST_NOT_DIVISIBLE_4\\\");\\n\\n        _stakingToken = config.stakingToken;\\n        _allianceRegistry = config.allianceRegistry;\\n        _genesis = config.genesis;\\n        _resolveWindow = config.resolveWindow;\\n        _timePerDistance = t;\\n        _exitDuration = config.exitDuration;\\n        _acquireNumSpaceships = config.acquireNumSpaceships;\\n        _productionSpeedUp = config.productionSpeedUp;\\n        _frontrunningDelay = config.frontrunningDelay;\\n        _productionCapAsDuration = config.productionCapAsDuration;\\n        _upkeepProductionDecreaseRatePer10000th = config.upkeepProductionDecreaseRatePer10000th;\\n        _fleetSizeFactor6 = config.fleetSizeFactor6;\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    struct PlanetUpdateState {\\n        uint256 location;\\n        uint40 lastUpdated;\\n        bool active; // do you need to get the old ?\\n        uint32 numSpaceships; // do you need to get the old ?\\n        int40 travelingUpkeep;\\n        uint40 exitStartTime;\\n        uint40 newExitStartTime;\\n        uint32 overflow; // do you need to get the old ?\\n        address owner;\\n        address newOwner;\\n        bytes32 data;\\n    }\\n\\n    function _createPlanetUpdateState(Planet memory planet, uint256 location)\\n        internal\\n        view\\n        returns (PlanetUpdateState memory planetUpdate)\\n    {\\n        (bool active, uint32 currentNumSpaceships) = _activeNumSpaceships(planet.numSpaceships);\\n        planetUpdate.location = location;\\n        planetUpdate.lastUpdated = planet.lastUpdated;\\n        planetUpdate.active = active;\\n        planetUpdate.numSpaceships = currentNumSpaceships;\\n        planetUpdate.travelingUpkeep = planet.travelingUpkeep;\\n        planetUpdate.exitStartTime = planet.exitStartTime;\\n        planetUpdate.newExitStartTime = planet.exitStartTime;\\n        planetUpdate.overflow = planet.overflow;\\n        planetUpdate.owner = planet.owner;\\n        planetUpdate.newOwner = planet.owner;\\n        planetUpdate.data = _planetData(location);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computePlanetUpdateForTimeElapsed(PlanetUpdateState memory planetUpdate) internal view {\\n        if (planetUpdate.exitStartTime != 0) {\\n            if (_hasJustExited(planetUpdate.exitStartTime)) {\\n                planetUpdate.newExitStartTime = 0;\\n                planetUpdate.numSpaceships = 0;\\n                planetUpdate.travelingUpkeep = 0;\\n                planetUpdate.newOwner = address(0);\\n                planetUpdate.overflow = 0;\\n                planetUpdate.active = false; // event is emitted at the endof each write function\\n                // lastUpdated is set at the end directly on storage\\n                return;\\n            }\\n        }\\n\\n        uint256 timePassed = block.timestamp - planetUpdate.lastUpdated;\\n        uint16 production = _production(planetUpdate.data);\\n        uint256 produce = (timePassed * uint256(production) * _productionSpeedUp) / 1 hours;\\n\\n        // NOTE: the repaypemnt of upkeep always happen at a fixed rate (per planet), it is fully predictable\\n        uint256 upkeepRepaid = 0;\\n        if (planetUpdate.travelingUpkeep > 0) {\\n            upkeepRepaid = ((produce * _upkeepProductionDecreaseRatePer10000th) / 10000);\\n            if (upkeepRepaid > uint40(planetUpdate.travelingUpkeep)) {\\n                upkeepRepaid = uint40(planetUpdate.travelingUpkeep);\\n            }\\n            planetUpdate.travelingUpkeep = planetUpdate.travelingUpkeep - int40(uint40(upkeepRepaid));\\n        }\\n\\n        uint256 newNumSpaceships = planetUpdate.numSpaceships;\\n        uint256 extraUpkeepPaid = 0;\\n        if (_productionCapAsDuration > 0) {\\n            // NOTE no need of productionSpeedUp for the cap because _productionCapAsDuration can include it\\n            uint256 capWhenActive = _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\\n            uint256 cap = planetUpdate.active ? capWhenActive : 0;\\n\\n            if (newNumSpaceships > cap) {\\n                // NOTE do not decrease while exiting\\n                if (planetUpdate.newExitStartTime == 0) {\\n                    uint256 decreaseRate = 1800;\\n                    if (planetUpdate.overflow > 0) {\\n                        decreaseRate = (planetUpdate.overflow * 1800) / capWhenActive;\\n                        if (decreaseRate < 1800) {\\n                            decreaseRate = 1800;\\n                        }\\n                    }\\n\\n                    uint256 decrease = (timePassed * decreaseRate) / 1 hours;\\n                    if (decrease > newNumSpaceships - cap) {\\n                        decrease = newNumSpaceships - cap;\\n                    }\\n                    if (decrease > newNumSpaceships) {\\n                        if (planetUpdate.active) {\\n                            extraUpkeepPaid = produce - upkeepRepaid + newNumSpaceships;\\n                        }\\n                        newNumSpaceships = 0;\\n                    } else {\\n                        if (planetUpdate.active) {\\n                            extraUpkeepPaid = produce - upkeepRepaid + decrease;\\n                        }\\n                        newNumSpaceships -= decrease;\\n                    }\\n                }\\n            } else {\\n                if (planetUpdate.active) {\\n                    uint256 maxIncrease = cap - newNumSpaceships;\\n                    uint256 increase = produce - upkeepRepaid;\\n                    if (increase > maxIncrease) {\\n                        extraUpkeepPaid = increase - maxIncrease;\\n                        increase = maxIncrease;\\n                    }\\n                    newNumSpaceships += increase;\\n                    // solhint-disable-next-line no-empty-blocks\\n                } else {\\n                    // not effect currently, when inactive, cap == 0, meaning zero spaceship here\\n                    // NOTE: we could do the following assuming we act on upkeepRepaid when inactive, we do not do that currently\\n                    //  extraUpkeepPaid = produce - upkeepRepaid;\\n                }\\n            }\\n\\n            if (planetUpdate.active) {\\n                // travelingUpkeep can go negative allow you to charge up your planet for later use, up to 7 days\\n                int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) - int256(extraUpkeepPaid);\\n                // TODO add _aquireNumSpaceships ? (+ see other place where this is computed)\\n                if (newTravelingUpkeep < int256(cap)) {\\n                    newTravelingUpkeep = -int256(cap);\\n                }\\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n            }\\n        } else {\\n            if (planetUpdate.active) {\\n                newNumSpaceships += (timePassed * uint256(production) * _productionSpeedUp) / 1 hours - upkeepRepaid;\\n            } else {\\n                // NOTE no need to overflow here  as there is no production cap, so no incentive to regroup spaceships\\n                uint256 decrease = (timePassed * 1800) / 1 hours;\\n                if (decrease > newNumSpaceships) {\\n                    decrease = newNumSpaceships;\\n                    newNumSpaceships = 0;\\n                } else {\\n                    newNumSpaceships -= decrease;\\n                }\\n            }\\n        }\\n\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n        planetUpdate.numSpaceships = uint32(newNumSpaceships);\\n\\n        // TODO remove\\n        // console.log(\\n        //     \\\"extraUpkeepPaid %i, numSpaceships: %i, upkeepRepaid: %i,\\\",\\n        //     extraUpkeepPaid,\\n        //     planetUpdate.numSpaceships,\\n        //     upkeepRepaid\\n        // );\\n    }\\n\\n    function _setPlanet(Planet storage planet, PlanetUpdateState memory planetUpdate) internal {\\n        if (planetUpdate.exitStartTime > 0 && planetUpdate.newExitStartTime == 0) {\\n            // exit has completed, newExitStartTime is not set to zero for interuption,\\n            // interuption is taken care below (owner changes)\\n            _handleExitComplete(planetUpdate);\\n        }\\n        if (planetUpdate.owner != planetUpdate.newOwner) {\\n            planet.owner = planetUpdate.newOwner;\\n            planet.ownershipStartTime = uint40(block.timestamp);\\n            // TODO stakedOwnershipStartTime ?\\n            // TODO handle staking pool ?\\n\\n            planet.exitStartTime = 0; // exit interupted // TODO event ?\\n\\n            emit Transfer(planetUpdate.owner, planetUpdate.newOwner, planetUpdate.location);\\n        }\\n        if (planetUpdate.newExitStartTime > 0 && planetUpdate.exitStartTime == 0) {\\n            planet.exitStartTime = planetUpdate.newExitStartTime;\\n        }\\n\\n        planet.numSpaceships = _setActiveNumSpaceships(planetUpdate.active, planetUpdate.numSpaceships);\\n        planet.travelingUpkeep = planetUpdate.travelingUpkeep;\\n\\n        planet.overflow = planetUpdate.overflow;\\n        planet.lastUpdated = uint40(block.timestamp);\\n    }\\n\\n    // was used to keep track of totalProduction, not needed anymore\\n    // function _setAccountFromPlanetUpdate(PlanetUpdateState memory planetUpdate) internal {\\n    //     if (planetUpdate.owner != planetUpdate.newOwner) {\\n    //         uint16 production = _production(planetUpdate.data);\\n    //         if (planetUpdate.owner != address(0)) {\\n    //             _accounts[planetUpdate.owner].totalProduction -= production;\\n    //         }\\n    //         if (planetUpdate.newOwner != address(0)) {\\n    //             _accounts[planetUpdate.newOwner].totalProduction += production;\\n    //         }\\n    //     }\\n    // }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // STAKING / PRODUCTION CAPTURE\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _acquire(\\n        address player,\\n        uint256 stake,\\n        uint256 location\\n    ) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(location);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n        require(stake == uint256(_stake(planetUpdate.data)) * (DECIMALS_18), \\\"INVALID_AMOUNT\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Staking logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForStaking(player, planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Update Space Discovery\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setDiscoveryAfterStaking(location);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Emit Event\\n        // -----------------------------------------------------------------------------------------------------------\\n        emit PlanetStake(\\n            player,\\n            location,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow,\\n            stake\\n        );\\n    }\\n\\n    function _computePlanetUpdateForStaking(address player, PlanetUpdateState memory planetUpdate) internal view {\\n        require(!planetUpdate.active, \\\"STILL_ACTIVE\\\");\\n\\n        uint32 defense;\\n        // NOTE : natives are back automatically once spaceships reaches zero (here we know we are not active)\\n        // TODO consider making natives come back over time => would need to compute the time numSpaceship became zero\\n        if (planetUpdate.numSpaceships == 0) {\\n            defense = _natives(planetUpdate.data);\\n        } else {\\n            // Do not allow staking over occupied planets, they are going to zero at some point though\\n            // TODO owner == address(0) ? is it possible for address(0) + numSpaceships > 0 ?\\n            require(planetUpdate.owner == player || planetUpdate.numSpaceships == 0, \\\"OCCUPIED\\\");\\n\\n            // used to be the following (but this gave too many cons to send spaceships to non-active planets):\\n            // TODO reconsider or remove natives entirely ?\\n            // if (mplanet.owner != sender) {\\n            //     defense = currentNumSpaceships;\\n            // } else {\\n            //     defense = 0;\\n            // }\\n        }\\n\\n        uint16 production = _production(planetUpdate.data);\\n        uint32 cap = uint32(_acquireNumSpaceships + (production * _productionCapAsDuration) / 1 hours);\\n\\n        // TODO ensure a player staking on a planet it previously exited work here\\n        planetUpdate.newOwner = player;\\n        if (defense != 0) {\\n            (uint32 attackerLoss, ) = _computeFight(_acquireNumSpaceships, defense, 10000, _defense(planetUpdate.data));\\n            // attacker alwasy win as defense (and stats.native) is restricted to 3500\\n            // (attackerLoss: 0, defenderLoss: 0) would mean defense was zero\\n            require(attackerLoss < _acquireNumSpaceships, \\\"FAILED_CAPTURED\\\");\\n            planetUpdate.numSpaceships = _acquireNumSpaceships - attackerLoss;\\n\\n            // NOTE cannot be overflow here as staking provide a number of spaceships below that\\n            planetUpdate.overflow = 0;\\n        } else {\\n            // NOTE this else is currently not possible now that we use numSpaceships == 0 for natives\\n            planetUpdate.numSpaceships += _acquireNumSpaceships;\\n            if (_productionCapAsDuration > 0) {\\n                if (planetUpdate.numSpaceships > cap) {\\n                    planetUpdate.overflow = planetUpdate.numSpaceships - cap;\\n                } else {\\n                    planetUpdate.overflow = 0;\\n                }\\n            }\\n        }\\n\\n        // NOTE when staking on a planet, we set an allowance for traveling upkeep\\n        planetUpdate.travelingUpkeep = -int32(cap);\\n        planetUpdate.active = true;\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _setDiscoveryAfterStaking(uint256 location) internal {\\n        Discovered memory discovered = _discovered;\\n\\n        int256 x = int256(int128(int256(location & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)));\\n        int256 y = int256(int128(int256(location >> 128)));\\n\\n        bool changes = false;\\n        if (x < 0) {\\n            require(-x <= int256(uint256(discovered.minX)), \\\"NOT_REACHABLE_YET_MINX\\\");\\n            x = -x + EXPANSION;\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minX)) < x) {\\n                discovered.minX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        } else {\\n            require(x <= int256(uint256(discovered.maxX)), \\\"NOT_REACHABLE_YET_MAXX\\\");\\n            x = x + EXPANSION;\\n            if (x > UINT32_MAX) {\\n                x = UINT32_MAX;\\n            }\\n            if (discovered.maxX < uint32(uint256(x))) {\\n                discovered.maxX = uint32(uint256(x));\\n                changes = true;\\n            }\\n        }\\n\\n        if (y < 0) {\\n            require(-y <= int256(uint256(discovered.minY)), \\\"NOT_REACHABLE_YET_MINY\\\");\\n            y = -y + EXPANSION;\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.minY)) < y) {\\n                discovered.minY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        } else {\\n            require(y <= int256(uint256(discovered.maxY)), \\\"NOT_REACHABLE_YET_MAXY\\\");\\n            y = y + EXPANSION;\\n            if (y > UINT32_MAX) {\\n                y = UINT32_MAX;\\n            }\\n            if (int256(uint256(discovered.maxY)) < y) {\\n                discovered.maxY = uint32(uint256(y));\\n                changes = true;\\n            }\\n        }\\n        if (changes) {\\n            _discovered = discovered;\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // EXITS / WITHDRAWALS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _handleExitComplete(PlanetUpdateState memory planetUpdate) internal {\\n        uint256 stake = _completeExit(planetUpdate.owner, planetUpdate.location, planetUpdate.data);\\n\\n        // optional so we can use it in the batch withdraw,\\n        uint256 newStake = _stakeReadyToBeWithdrawn[planetUpdate.owner] + stake;\\n        _stakeReadyToBeWithdrawn[planetUpdate.owner] = newStake;\\n        emit StakeToWithdraw(planetUpdate.owner, newStake);\\n    }\\n\\n    function _completeExit(\\n        address owner,\\n        uint256 location,\\n        bytes32 data\\n    ) internal returns (uint256 stake) {\\n        stake = uint256(_stake(data)) * (DECIMALS_18);\\n        emit ExitComplete(owner, location, stake);\\n\\n        // TODO handle Staking pool release ?\\n        // (maybe not necessary here, can do in withdrawals?)\\n\\n        // --------------------------------------------------------\\n        // Extra Reward was added\\n        // --------------------------------------------------------\\n        uint256 rewardId = _rewards[location];\\n        if (rewardId != 0) {\\n            // rewardId would contains the package. maybe this could be handled by an external contract\\n            _rewardsToWithdraw[owner][rewardId] = true;\\n            _rewards[location] = 0; // reset\\n            // if you had reward to a planet in he process of exiting,\\n            // you are adding the reward to the player exiting unless _setPlanetAfterExit is called first\\n            emit RewardToWithdraw(owner, location, rewardId);\\n        }\\n        // --------------------------------------------------------\\n    }\\n\\n    function _exitFor(address owner, uint256 location) internal {\\n        Planet storage planet = _getPlanet(location);\\n        require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n        require(planet.exitStartTime == 0, \\\"EXITING_ALREADY\\\");\\n        planet.exitStartTime = uint40(block.timestamp);\\n        emit PlanetExit(owner, location);\\n    }\\n\\n    function _fetchAndWithdrawFor(address owner, uint256[] calldata locations) internal {\\n        uint256 addedStake = 0;\\n        for (uint256 i = 0; i < locations.length; i++) {\\n            Planet storage planet = _getPlanet(locations[i]);\\n            if (_hasJustExited(planet.exitStartTime)) {\\n                require(owner == planet.owner, \\\"NOT_OWNER\\\");\\n                emit Transfer(owner, address(0), locations[i]);\\n                addedStake += _completeExit(planet.owner, locations[i], _planetData(locations[i]));\\n                planet.owner = address(0);\\n                planet.ownershipStartTime = 0;\\n                planet.exitStartTime = 0;\\n                planet.numSpaceships = 0;\\n                planet.overflow = 0;\\n                planet.travelingUpkeep = 0;\\n                planet.lastUpdated = uint40(block.timestamp);\\n            }\\n        }\\n        uint256 newStake = _stakeReadyToBeWithdrawn[owner] + addedStake;\\n        _unsafe_withdrawAll(owner, newStake);\\n    }\\n\\n    function _unsafe_withdrawAll(address owner, uint256 amount) internal {\\n        _stakeReadyToBeWithdrawn[owner] = 0;\\n        emit StakeToWithdraw(owner, amount);\\n        require(_stakingToken.transfer(owner, amount), \\\"FAILED_TRANSFER\\\");\\n        // TODO Staking Pool\\n        emit StakeToWithdraw(owner, 0);\\n    }\\n\\n    function _hasJustExited(uint40 exitTime) internal view returns (bool) {\\n        return exitTime > 0 && block.timestamp > exitTime + _exitDuration;\\n    }\\n\\n    function _ping(uint256 location) internal {\\n        Planet storage planet = _getPlanet(location);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n        _setPlanet(planet, planetUpdate);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // REWARDS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _addReward(uint256 location, address sponsor) internal {\\n        uint256 rewardId = _rewards[location];\\n        if (rewardId == 0) {\\n            rewardId = ++_prevRewardIds[sponsor];\\n            _rewards[location] = (uint256(uint160(sponsor)) << 96) + rewardId;\\n        }\\n        // TODO should it fails if different sponsor added reward before\\n\\n        // TODO rewardId association with the actual rewards // probably contract address holding the reward\\n        emit RewardSetup(location, sponsor, rewardId);\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET SENDING\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _sendFor(\\n        uint256 fleetId,\\n        address operator,\\n        FleetLaunch memory launch\\n    ) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage planet = _getPlanet(launch.from);\\n        PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, launch.from);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(planet.exitStartTime == 0, \\\"PLANET_EXIT\\\");\\n        require(launch.fleetSender == planet.owner, \\\"NOT_OWNER\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(planetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Requirements post Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(planetUpdate.numSpaceships >= launch.quantity, \\\"SPACESHIPS_NOT_ENOUGH\\\");\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Sending logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForFleetLaunch(planetUpdate, launch.quantity);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n        _setPlanet(planet, planetUpdate);\\n        // _setAccountFromPlanetUpdate(planetUpdate);\\n\\n        _setFleetFlyingSlot(launch.from, launch.quantity);\\n\\n        // TODO add debt info\\n        _fleets[fleetId] = Fleet({\\n            launchTime: uint40(block.timestamp),\\n            owner: launch.fleetOwner,\\n            quantity: launch.quantity\\n        });\\n\\n        emit FleetSent(\\n            launch.fleetSender,\\n            launch.fleetOwner,\\n            launch.from,\\n            operator,\\n            fleetId,\\n            launch.quantity,\\n            planetUpdate.numSpaceships,\\n            planetUpdate.travelingUpkeep,\\n            planetUpdate.overflow\\n        );\\n    }\\n\\n    function _computePlanetUpdateForFleetLaunch(PlanetUpdateState memory planetUpdate, uint32 quantity) internal view {\\n        planetUpdate.numSpaceships -= quantity;\\n        if (_productionCapAsDuration > 0) {\\n            if (planetUpdate.active) {\\n                // NOTE we do not update travelingUpkeep on Inactive planets\\n                //  these get reset on staking\\n                uint16 production = _production(planetUpdate.data);\\n                uint256 cap = _acquireNumSpaceships + (uint256(production) * _productionCapAsDuration) / 1 hours;\\n\\n                int256 newTravelingUpkeep = int256(planetUpdate.travelingUpkeep) + int256(uint256(quantity));\\n                if (newTravelingUpkeep > int256(cap)) {\\n                    newTravelingUpkeep = int256(cap);\\n                }\\n                planetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n            }\\n\\n            if (planetUpdate.overflow > quantity) {\\n                planetUpdate.overflow -= quantity;\\n            } else {\\n                planetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _setFleetFlyingSlot(uint256 from, uint32 quantity) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // record flying fleets (to prevent front-running, see resolution)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        uint32 flying = _inFlight[from][timeSlot].flying;\\n        flying = flying + quantity;\\n        require(flying >= quantity, \\\"ORBIT_OVERFLOW\\\"); // unlikely to ever happen,\\n        // would need a huge amount of spaceships to be received and each in turn being sent\\n        // TOEXPLORE could also cap, that would result in some fleet being able to escape.\\n        _inFlight[from][timeSlot].flying = flying;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // FLEET RESOLUTION, ATTACK / REINFORCEMENT\\n    // ---------------------------------------------------------------------------------------------------------------\\n    struct ResolutionState {\\n        address fleetOwner;\\n        uint40 fleetLaunchTime;\\n        uint32 fleetQuantity;\\n        bytes32 fromData;\\n        uint32 inFlightFleetLoss;\\n        uint32 inFlightPlanetLoss;\\n        bool gifting;\\n        bool taxed;\\n        bool victory; // TODO ? and check old behavior,\\n        // for example on fleet_after_Exit the victory is true if numSPaceshipArrived > 0\\n        uint32 attackerLoss;\\n        uint32 defenderLoss;\\n        uint32 orbitDefense1;\\n        uint32 orbitDefenseDestroyed1;\\n        uint32 orbitDefense2;\\n        uint32 orbitDefenseDestroyed2;\\n        bool accumulating;\\n        uint40 arrivalTime;\\n        uint32 accumulatedDefenseAdded;\\n        uint32 accumulatedAttackAdded;\\n        uint16 attackPower;\\n    }\\n\\n    function _resolveFleet(uint256 fleetId, FleetResolution calldata resolution) internal {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Initialise State Update\\n        // -----------------------------------------------------------------------------------------------------------\\n        Planet storage toPlanet = _getPlanet(resolution.to);\\n        PlanetUpdateState memory toPlanetUpdate = _createPlanetUpdateState(toPlanet, resolution.to);\\n        ResolutionState memory rState = _createResolutionState(_fleets[fleetId], resolution.from);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check requirements\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        require(rState.fleetQuantity > 0, \\\"FLEET_DO_NOT_EXIST\\\");\\n        _requireCorrectDistance(\\n            resolution.distance,\\n            resolution.from,\\n            resolution.to,\\n            rState.fromData,\\n            toPlanetUpdate.data\\n        );\\n        _requireCorrectTimeAndUpdateArrivalTime(\\n            resolution.distance,\\n            resolution.arrivalTimeWanted,\\n            rState.fleetLaunchTime,\\n            rState.fromData,\\n            rState\\n        );\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Compute Basic Planet Updates\\n        // -----------------------------------------------------------------------------------------------------------\\n        _computePlanetUpdateForTimeElapsed(toPlanetUpdate);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Traveling logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _computeInFlightLossForFleet(rState, resolution);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Resolution logic...\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _updateFleetForGifting(rState, resolution, toPlanetUpdate.owner);\\n\\n        _computeResolutionResult(rState, toPlanetUpdate, resolution);\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Write New State\\n        // -----------------------------------------------------------------------------------------------------------\\n\\n        _recordInOrbitLossAfterAttack(rState, toPlanetUpdate);\\n\\n        _recordOrbitLossAccountingForFleetOrigin(rState, resolution);\\n\\n        _setTravelingUpkeepFromOrigin(fleetId, rState, resolution.from);\\n\\n        _setPlanet(toPlanet, toPlanetUpdate);\\n\\n        _setAccumulatedAttack(rState, toPlanetUpdate);\\n\\n        // _setAccountFromPlanetUpdate(toPlanetUpdate); // TODO remove, else think about the fromPlanet ?\\n\\n        // TODO quantity should be kept ?\\n        //  so Alliance Contract can act on that value ?, could use 1st bit indicator\\n        _fleets[fleetId].quantity = 0;\\n\\n        // -----------------------------------------------------------------------------------------------------------\\n        // Events\\n        // -----------------------------------------------------------------------------------------------------------\\n        emit FleetArrived(\\n            fleetId,\\n            rState.fleetOwner,\\n            toPlanetUpdate.owner,\\n            resolution.to,\\n            rState.gifting,\\n            rState.attackerLoss,\\n            rState.defenderLoss,\\n            rState.inFlightFleetLoss,\\n            rState.inFlightPlanetLoss,\\n            rState.victory,\\n            toPlanetUpdate.numSpaceships,\\n            toPlanetUpdate.travelingUpkeep,\\n            toPlanetUpdate.overflow,\\n            rState.accumulatedDefenseAdded,\\n            rState.accumulatedAttackAdded\\n        );\\n    }\\n\\n    function _setTravelingUpkeepFromOrigin(\\n        uint256 fleetID,\\n        ResolutionState memory rState,\\n        uint256 location\\n    ) internal {\\n        if (rState.attackerLoss > 0) {\\n            // // we have to update the origin\\n            Planet storage fromPlanet = _planets[location];\\n            PlanetUpdateState memory fromPlanetUpdate = _createPlanetUpdateState(fromPlanet, location);\\n            _computePlanetUpdateForTimeElapsed(fromPlanetUpdate);\\n\\n            uint32 production = _production(fromPlanetUpdate.data);\\n            int256 newTravelingUpkeep = int256(fromPlanetUpdate.travelingUpkeep) - int256(int32(rState.attackerLoss));\\n            if (newTravelingUpkeep < -int256((7 days * uint256(production) * _productionSpeedUp) / 1 hours)) {\\n                newTravelingUpkeep = -int256((7 days * uint256(production) * _productionSpeedUp) / 1 hours);\\n            }\\n            fromPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n\\n            _setPlanet(fromPlanet, fromPlanetUpdate);\\n\\n            emit TravelingUpkeepReductionFromDestruction(\\n                location,\\n                fleetID,\\n                fromPlanetUpdate.numSpaceships,\\n                fromPlanetUpdate.travelingUpkeep,\\n                fromPlanetUpdate.overflow\\n            );\\n        }\\n    }\\n\\n    function _setAccumulatedAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate) internal {\\n        if (rState.victory) {\\n            // victory, past attack has been succesful in capturing the planet, They do not count anymore\\n            delete _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\\n        } else if (rState.accumulating) {\\n            AccumulatedAttack storage attack = _attacks[toPlanetUpdate.location][rState.fleetOwner][rState.arrivalTime];\\n\\n            attack.target = toPlanetUpdate.owner;\\n            attack.damageCausedSoFar = rState.defenderLoss + rState.inFlightPlanetLoss;\\n            attack.numAttackSpent = rState.attackerLoss;\\n            attack.averageAttackPower = rState.attackPower;\\n        }\\n    }\\n\\n    function _createResolutionState(Fleet storage fleet, uint256 from)\\n        internal\\n        view\\n        returns (ResolutionState memory rState)\\n    {\\n        rState.fleetOwner = fleet.owner;\\n        rState.fleetLaunchTime = fleet.launchTime;\\n        rState.fleetQuantity = fleet.quantity;\\n        rState.fromData = _planetData(from);\\n        rState.attackPower = _attack(rState.fromData);\\n    }\\n\\n    function _computeInFlightLossForFleet(ResolutionState memory rState, FleetResolution memory resolution)\\n        internal\\n        view\\n    {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // check if fleet was attacked while departing (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\\n        uint32 destroyed = _inFlight[resolution.from][timeSlot].destroyed;\\n        uint32 originalQuantity = rState.fleetQuantity;\\n        if (destroyed < rState.fleetQuantity) {\\n            rState.fleetQuantity -= uint32(destroyed);\\n        } else {\\n            rState.fleetQuantity = 0;\\n        }\\n\\n        rState.inFlightFleetLoss = originalQuantity - rState.fleetQuantity;\\n        // -----------------------------------------------------------------------------------------------------------\\n    }\\n\\n    function _recordOrbitLossAccountingForFleetOrigin(ResolutionState memory rState, FleetResolution memory resolution)\\n        internal\\n    {\\n        if (rState.inFlightFleetLoss > 0) {\\n            uint256 timeSlot = rState.fleetLaunchTime / (_frontrunningDelay / 2);\\n\\n            // NOTE we already computed that destroyed cannot be smaller than inFlightFleetLoss\\n            //  see _computeInFlightLossForFleet\\n            _inFlight[resolution.from][timeSlot].destroyed -= rState.inFlightFleetLoss;\\n        }\\n    }\\n\\n    function _updateFleetForGifting(\\n        ResolutionState memory rState,\\n        FleetResolution memory resolution,\\n        address destinationOwner\\n    ) internal view {\\n        (bool gifting, bool taxed) = _computeGifting(destinationOwner, resolution, rState);\\n        rState.gifting = gifting;\\n        rState.taxed = taxed;\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeGifting(\\n        address destinationOwner,\\n        FleetResolution memory resolution,\\n        ResolutionState memory rState\\n    ) internal view returns (bool gifting, bool taxed) {\\n        if (destinationOwner == address(0)) {\\n            // destination has no owner : this is an attack\\n            return (false, false);\\n        }\\n        if (destinationOwner == rState.fleetOwner && destinationOwner == resolution.fleetSender) {\\n            // destination is sender is fleet owner: this is a non-taxed gift\\n            return (true, false);\\n        }\\n\\n        if (resolution.gift || destinationOwner == rState.fleetOwner) {\\n            // intent was gift\\n            if (\\n                resolution.specific == address(0) ||\\n                resolution.specific == destinationOwner ||\\n                destinationOwner == rState.fleetOwner\\n            ) {\\n                // and it was for anyone or specific destination owner that is the same as the current one\\n                // or it was simply that fleetOwner = destinationOwner\\n\\n                (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                    resolution.fleetSender,\\n                    destinationOwner,\\n                    rState.fleetLaunchTime\\n                );\\n                return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n            }\\n\\n            if (resolution.specific == address(1)) {\\n                // or the specific specify any common alliances (1)\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 senderJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        rState.fleetOwner,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (fleetOwnerJoinTime > 0, senderJoinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n\\n            if (uint160(resolution.specific) > 1) {\\n                // or a specific one that matches\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry.getAllianceData(\\n                    destinationOwner,\\n                    IAlliance(resolution.specific)\\n                );\\n\\n                if (joinTimeToSpecific > 0) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n        } else {\\n            // intent was attack\\n            if (resolution.specific == address(1)) {\\n                // and the attack was on any non-allies\\n\\n                if (rState.fleetOwner == resolution.fleetSender) {\\n                    // make it a gift if the destination owner is actually an ally\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (joinTime > 0, joinTime > rState.fleetLaunchTime);\\n                } else {\\n                    (, uint96 senderJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    (, uint96 fleetOwnerJoinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        rState.fleetOwner,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (fleetOwnerJoinTime > 0, senderJoinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n\\n            if (uint160(resolution.specific) > 1 && resolution.specific != destinationOwner) {\\n                // but specific not matching current owner\\n\\n                (uint96 joinTimeToSpecific, ) = _allianceRegistry.getAllianceData(\\n                    destinationOwner,\\n                    IAlliance(resolution.specific)\\n                );\\n\\n                // make it a gift if the destination is not matching the specific alliance\\n                // (or owner, in which case since it is not an alliance, it will also not match)\\n                if (joinTimeToSpecific == 0) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        destinationOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    return (true, joinTime == 0 || joinTime > rState.fleetLaunchTime);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _computeResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        FleetResolution memory resolution\\n    ) internal view {\\n        if (rState.gifting) {\\n            _computeGiftingResolutionResult(rState, toPlanetUpdate);\\n        } else {\\n            _computeAttackResolutionResult(rState, toPlanetUpdate, resolution);\\n        }\\n    }\\n\\n    function _computeAttackResolutionResult(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        FleetResolution memory resolution\\n    ) internal view {\\n        // NOTE natives come back to power once numSPaceships == 0 and planet not active\\n        if (toPlanetUpdate.numSpaceships == 0 && !toPlanetUpdate.active) {\\n            _updatePlanetUpdateStateAndResolutionStateForNativeAttack(rState, toPlanetUpdate);\\n        } else {\\n            if (block.timestamp < rState.arrivalTime + 45 minutes) {\\n                if (rState.fleetOwner != resolution.fleetSender) {\\n                    (, uint96 joinTime) = _allianceRegistry.havePlayersAnAllianceInCommon(\\n                        resolution.fleetSender,\\n                        rState.fleetOwner,\\n                        rState.fleetLaunchTime\\n                    );\\n                    rState.accumulating = joinTime != 0 && joinTime <= rState.fleetLaunchTime;\\n                } else {\\n                    rState.accumulating = true;\\n                }\\n\\n                if (rState.accumulating) {\\n                    AccumulatedAttack memory acc = _attacks[toPlanetUpdate.location][rState.fleetOwner][\\n                        rState.arrivalTime\\n                    ];\\n                    if (acc.target == toPlanetUpdate.owner && acc.numAttackSpent != 0) {\\n                        rState.attackPower = uint16(\\n                            uint256(\\n                                rState.attackPower * rState.fleetQuantity + acc.averageAttackPower * acc.numAttackSpent\\n                            ) / (rState.fleetQuantity + acc.numAttackSpent)\\n                        );\\n                        rState.accumulatedAttackAdded = acc.numAttackSpent;\\n                        rState.accumulatedDefenseAdded = acc.damageCausedSoFar;\\n                    }\\n                }\\n            }\\n\\n            _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(rState, toPlanetUpdate);\\n        }\\n    }\\n\\n    function _computeGiftingResolutionResult(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\\n        internal\\n        view\\n    {\\n        if (rState.taxed) {\\n            rState.fleetQuantity = uint32(\\n                uint256(rState.fleetQuantity) - (uint256(rState.fleetQuantity) * GIFT_TAX_PER_10000) / 10000\\n            );\\n        }\\n        uint256 newNumSpaceships = toPlanetUpdate.numSpaceships + rState.fleetQuantity;\\n        if (newNumSpaceships >= ACTIVE_MASK) {\\n            newNumSpaceships = ACTIVE_MASK - 1;\\n        }\\n\\n        toPlanetUpdate.numSpaceships = uint32(newNumSpaceships);\\n        if (!toPlanetUpdate.active) {\\n            // NOTE: not active, overflow is applied on cap = 0\\n            if (toPlanetUpdate.numSpaceships > toPlanetUpdate.overflow) {\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            }\\n        } else {\\n            uint32 cap = uint32(_acquireNumSpaceships + _production(toPlanetUpdate.data) * _productionCapAsDuration) /\\n                1 hours;\\n            if (_productionCapAsDuration > 0 && newNumSpaceships > cap) {\\n                if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\\n                    toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\\n                }\\n            } else {\\n                toPlanetUpdate.overflow = 0;\\n            }\\n        }\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForNativeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        uint16 attack = _attack(rState.fromData);\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        uint16 natives = _natives(toPlanetUpdate.data); // TODO ? attacks ?\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(rState.fleetQuantity, natives, attack, defense);\\n        rState.attackerLoss = attackerLoss;\\n        if (defenderLoss == natives && rState.fleetQuantity > attackerLoss) {\\n            // (attackerLoss: 0, defenderLoss: 0) means that numAttack was zero as natives cannot be zero\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity - attackerLoss;\\n            rState.defenderLoss = defenderLoss;\\n            rState.victory = true;\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            // solhint-disable-next-line no-empty-blocks\\n        }\\n        // NOTE else (attacker lost) then nothing happen\\n    }\\n\\n    function _updateResolutionStateFromOrbitDefense(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        // -----------------------------------------------------------------------------------------------------------\\n        // consider fleets that just departed from the planet (used to prevent front-running, see fleet sending)\\n        // -----------------------------------------------------------------------------------------------------------\\n        uint256 timeSlot = block.timestamp / (_frontrunningDelay / 2);\\n        InFlight storage slot1 = _inFlight[toPlanetUpdate.location][timeSlot - 1];\\n        rState.orbitDefense1 = slot1.flying > 2**31 ? 2**31 - 1 : uint32(slot1.flying);\\n        rState.orbitDefenseDestroyed1 = slot1.destroyed > 2**31 ? 2**31 - 1 : uint32(slot1.destroyed);\\n        InFlight storage slot2 = _inFlight[toPlanetUpdate.location][timeSlot];\\n        rState.orbitDefense2 = slot2.flying > 2**31 ? 2**31 - 1 : uint32(slot2.flying);\\n        rState.orbitDefenseDestroyed2 = slot2.destroyed > 2**31 ? 2**31 - 1 : uint32(slot2.destroyed);\\n        // // numDefense = uint32(Math.min(flying1 + flying2 + numDefense, 2**32 - 1));\\n    }\\n\\n    function _updatePlanetUpdateStateAndResolutionStateForPlanetAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate\\n    ) internal view {\\n        _updateResolutionStateFromOrbitDefense(rState, toPlanetUpdate);\\n        uint256 numDefense = toPlanetUpdate.numSpaceships +\\n            rState.accumulatedDefenseAdded +\\n            rState.orbitDefense1 +\\n            rState.orbitDefense2;\\n        uint16 production = _production(toPlanetUpdate.data);\\n\\n        if (numDefense == 0 && rState.fleetQuantity > 0) {\\n            // scenario where there is actually no defense on the place,\\n            // TODO check if we could already assume active = false ?\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity;\\n            if (!toPlanetUpdate.active) {\\n                // numDefense = 0 so numAttack is the overflow, attacker took over\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint32 cap = uint32(_acquireNumSpaceships + (production * _productionCapAsDuration) / 1 hours);\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        // numDefense = 0 so numAttack is the overflow, attacker took over\\n                        toPlanetUpdate.overflow = uint32(toPlanetUpdate.numSpaceships - cap);\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n\\n            rState.victory = true;\\n        } else {\\n            _computeAttack(rState, toPlanetUpdate, numDefense);\\n            _computeTravelingUpkeepReductionAfterAttack(rState, toPlanetUpdate, production);\\n        }\\n    }\\n\\n    function _computeTravelingUpkeepReductionAfterAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint16 production\\n    ) internal view {\\n        // allow the attacker to pay for upkeep as part of the attack\\n        // only get to keep the upkeep that was there as a result of spaceships sent away\\n\\n        int256 totalLoss = int256(uint256(rState.defenderLoss + rState.inFlightPlanetLoss + rState.attackerLoss));\\n        int256 newTravelingUpkeep = int256(toPlanetUpdate.travelingUpkeep) - totalLoss;\\n        if (newTravelingUpkeep < -int256((7 days * uint256(production) * _productionSpeedUp) / 1 hours)) {\\n            newTravelingUpkeep = -int256((7 days * uint256(production) * _productionSpeedUp) / 1 hours);\\n        }\\n        toPlanetUpdate.travelingUpkeep = int40(newTravelingUpkeep);\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _computeAttack(\\n        ResolutionState memory rState,\\n        PlanetUpdateState memory toPlanetUpdate,\\n        uint256 numDefense\\n    ) internal view {\\n        uint16 attack = rState.attackPower;\\n        uint16 defense = _defense(toPlanetUpdate.data);\\n        (uint32 attackerLoss, uint32 defenderLoss) = _computeFight(\\n            rState.fleetQuantity + rState.accumulatedAttackAdded,\\n            numDefense,\\n            attack,\\n            defense\\n        );\\n        rState.defenderLoss = defenderLoss;\\n        rState.attackerLoss = attackerLoss;\\n\\n        // (attackerLoss: 0, defenderLoss: 0) could either mean attack was zero or defense was zero :\\n        if (rState.fleetQuantity > 0 && rState.defenderLoss == numDefense) {\\n            // NOTE Attacker wins\\n\\n            // all orbiting fleets are destroyed, inFlightPlanetLoss is all that is left\\n            rState.inFlightPlanetLoss = uint32(\\n                numDefense - toPlanetUpdate.numSpaceships - rState.accumulatedDefenseAdded\\n            );\\n\\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\\n\\n            toPlanetUpdate.numSpaceships = rState.fleetQuantity + rState.accumulatedAttackAdded - attackerLoss;\\n            rState.victory = true;\\n\\n            toPlanetUpdate.newOwner = rState.fleetOwner;\\n\\n            if (!toPlanetUpdate.active) {\\n                // attack took over, overflow is numSpaceships\\n                toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships;\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_acquireNumSpaceships + (production * _productionCapAsDuration) / 1 hours);\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (toPlanetUpdate.numSpaceships - cap > toPlanetUpdate.overflow) {\\n                            toPlanetUpdate.overflow = toPlanetUpdate.numSpaceships - cap;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else if (rState.attackerLoss == rState.fleetQuantity + rState.accumulatedAttackAdded) {\\n            // NOTE Defender wins\\n\\n            if (defenderLoss > toPlanetUpdate.numSpaceships + rState.accumulatedDefenseAdded) {\\n                rState.inFlightPlanetLoss =\\n                    defenderLoss -\\n                    toPlanetUpdate.numSpaceships -\\n                    rState.accumulatedDefenseAdded;\\n\\n                toPlanetUpdate.numSpaceships = 0;\\n\\n                if (rState.orbitDefense1 >= rState.inFlightPlanetLoss) {\\n                    rState.orbitDefense1 -= rState.inFlightPlanetLoss;\\n                    rState.orbitDefenseDestroyed1 += rState.inFlightPlanetLoss;\\n                } else {\\n                    rState.orbitDefenseDestroyed1 += rState.orbitDefense1;\\n                    uint32 extra = (rState.inFlightPlanetLoss - rState.orbitDefense1);\\n                    if (rState.orbitDefense2 >= extra) {\\n                        rState.orbitDefense2 -= extra;\\n                        rState.orbitDefenseDestroyed2 += extra;\\n                    } else {\\n                        rState.orbitDefenseDestroyed2 += rState.orbitDefense2;\\n                        rState.orbitDefense2 = 0; // should never reach minus but let simply set it to zero\\n                    }\\n                    rState.orbitDefense1 = 0;\\n                }\\n            } else {\\n                toPlanetUpdate.numSpaceships =\\n                    toPlanetUpdate.numSpaceships +\\n                    rState.accumulatedDefenseAdded -\\n                    defenderLoss;\\n            }\\n\\n            rState.defenderLoss = rState.defenderLoss - rState.inFlightPlanetLoss;\\n\\n            if (!toPlanetUpdate.active) {\\n                if (defenderLoss > toPlanetUpdate.overflow) {\\n                    toPlanetUpdate.overflow = 0;\\n                } else {\\n                    toPlanetUpdate.overflow -= defenderLoss;\\n                }\\n            } else {\\n                if (_productionCapAsDuration > 0) {\\n                    uint16 production = _production(toPlanetUpdate.data);\\n                    uint32 cap = uint32(_acquireNumSpaceships + (production * _productionCapAsDuration) / 1 hours);\\n                    if (toPlanetUpdate.numSpaceships > cap) {\\n                        if (defenderLoss <= toPlanetUpdate.overflow) {\\n                            toPlanetUpdate.overflow -= defenderLoss;\\n                        } else {\\n                            toPlanetUpdate.overflow = 0;\\n                        }\\n                    } else {\\n                        toPlanetUpdate.overflow = 0;\\n                    }\\n                }\\n            }\\n        } else {\\n            assert(false); // should not happen\\n        }\\n    }\\n\\n    function _recordInOrbitLossAfterAttack(ResolutionState memory rState, PlanetUpdateState memory toPlanetUpdate)\\n        internal\\n    {\\n        if (rState.inFlightPlanetLoss > 0) {\\n            InFlight storage slot1 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2) - 1];\\n            slot1.flying = rState.orbitDefense1;\\n            slot1.destroyed = rState.orbitDefenseDestroyed1;\\n\\n            InFlight storage slot2 = _inFlight[toPlanetUpdate.location][block.timestamp / (_frontrunningDelay / 2)];\\n            slot2.flying = rState.orbitDefense2;\\n            slot2.destroyed = rState.orbitDefenseDestroyed2;\\n        }\\n    }\\n\\n    function _computeFight(\\n        uint256 numAttack,\\n        uint256 numDefense,\\n        uint256 attack,\\n        uint256 defense\\n    ) internal view returns (uint32 attackerLoss, uint32 defenderLoss) {\\n        if (numAttack == 0 || numDefense == 0) {\\n            // this edge case need to be considered,\\n            // as the result of this function cannot tell from it whos is winning here\\n            return (0, 0);\\n        }\\n\\n        uint256 attackFactor = numAttack *\\n            ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numAttack) / numDefense));\\n        uint256 attackDamage = (attackFactor * attack) / defense / 1000000;\\n\\n        if (numDefense > attackDamage) {\\n            // attack fails\\n            attackerLoss = uint32(numAttack); // all attack destroyed\\n            defenderLoss = uint32(attackDamage); // 1 spaceship will be left at least as attackDamage < numDefense\\n        } else {\\n            // attack succeed\\n            uint256 defenseFactor = numDefense *\\n                ((1000000 - _fleetSizeFactor6) + ((_fleetSizeFactor6 * numDefense) / numAttack));\\n            uint256 defenseDamage = uint32((defenseFactor * defense) / attack / 1000000);\\n\\n            if (defenseDamage >= numAttack) {\\n                defenseDamage = numAttack - 1; // ensure 1 spaceship left\\n            }\\n\\n            attackerLoss = uint32(defenseDamage);\\n            defenderLoss = uint32(numDefense); // all defense destroyed\\n        }\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // PLANET STATS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _planetData(uint256 location) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_genesis, location));\\n    }\\n\\n    function _subLocation(bytes32 data) internal pure returns (int8 subX, int8 subY) {\\n        subX = 1 - int8(data.value8Mod(0, 3));\\n        subY = 1 - int8(data.value8Mod(2, 3));\\n    }\\n\\n    // // 4,5,5,10,10,15,15, 20, 20, 30,30,40,40,80,80,100\\n    // bytes32 constant stakeRange = 0x000400050005000A000A000F000F00140014001E001E00280028005000500064;\\n\\n    // 6, 8, 10, 12, 14, 16, 18, 20, 20, 22, 24, 32, 40, 48, 56, 72\\n    bytes32 internal constant stakeRange = 0x00060008000A000C000E00100012001400140016001800200028003000380048;\\n\\n    function _stake(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // return data.normal16(4, 0x000400050005000A000A000F000F00140014001E001E00280028005000500064);\\n        uint8 productionIndex = data.normal8(12); // production affect the stake value\\n\\n        // TODO remove or decide otherwise:\\n        // uint16 offset = data.normal16(4, 0x0000000100010002000200030003000400040005000500060006000700070008);\\n        // uint16 stakeIndex = productionIndex + offset;\\n        // if (stakeIndex < 4) {\\n        //     stakeIndex = 0;\\n        // } else if (stakeIndex > 19) {\\n        //     stakeIndex = 15;\\n        // } else {\\n        //     stakeIndex -= 4;\\n        // }\\n        uint16 stakeIndex = productionIndex;\\n        // skip stakeIndex * 2 + 0 as it is always zero in stakeRange\\n        return uint16(uint8(stakeRange[stakeIndex * 2 + 1]));\\n    }\\n\\n    function _production(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        // TODO TRY : 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4000,4400,4800,5400,6200,7200 ?\\n\\n        // 1800,2100,2400,2700,3000,3300,3600, 3600, 3600, 3600,4200,5400,6600,7800,9000,12000\\n        // 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0\\n        return data.normal16(12, 0x0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0); // per hour\\n    }\\n\\n    function _attack(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(20) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _defense(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 4000 + data.normal8(28) * 400; // 4,000 - 7,000 - 10,000\\n    }\\n\\n    function _speed(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 5005 + data.normal8(36) * 333; // 5,005 - 7,502.5 - 10,000\\n    }\\n\\n    function _natives(bytes32 data) internal pure returns (uint16) {\\n        require(_exists(data), \\\"PLANET_NOT_EXISTS\\\");\\n        return 15000 + data.normal8(44) * 3000; // 15,000 - 37,500 - 60,000\\n    }\\n\\n    function _exists(bytes32 data) internal pure returns (bool) {\\n        return data.value8Mod(52, 16) == 1; // 16 => 36 so : 1 planet per 6 (=24 min unit) square\\n        // also:\\n        // 20000 average starting numSpaceships (or max?)\\n        // speed of min unit = 30 min ( 1 hour per square)\\n        // production : 20000 per 6 hours\\n        // exit : 3 days ? => 72 distance\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // GETTERS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _getPlanet(uint256 location) internal view returns (Planet storage) {\\n        return _planets[location];\\n    }\\n\\n    function _getPlanetStats(uint256 location) internal view returns (PlanetStats memory) {\\n        bytes32 data = _planetData(location);\\n        require(_exists(data), \\\"no planet in this location\\\");\\n\\n        (int8 subX, int8 subY) = _subLocation(data);\\n        return\\n            PlanetStats({\\n                subX: subX,\\n                subY: subY,\\n                stake: _stake(data),\\n                production: _production(data),\\n                attack: _attack(data),\\n                defense: _defense(data),\\n                speed: _speed(data),\\n                natives: _natives(data)\\n            });\\n    }\\n\\n    // ---------------------------------------------------------------------------------------------------------------\\n    // UTILS\\n    // ---------------------------------------------------------------------------------------------------------------\\n\\n    function _requireCorrectDistance(\\n        uint256 distance,\\n        uint256 from,\\n        uint256 to,\\n        bytes32 fromPlanetData,\\n        bytes32 toPlanetData\\n    ) internal pure {\\n        // check input instead of compute sqrt\\n\\n        (int8 fromSubX, int8 fromSubY) = _subLocation(fromPlanetData);\\n        (int8 toSubX, int8 toSubY) = _subLocation(toPlanetData);\\n        uint256 distanceSquared = uint256(\\n            int256( // check input instead of compute sqrt\\n                ((int128(int256(to & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + toSubX) -\\n                    (int128(int256(from & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) * 4 + fromSubX)) **\\n                    2 +\\n                    ((int128(int256(to >> 128)) * 4 + toSubY) - (int128(int256(from >> 128)) * 4 + fromSubY))**2\\n            )\\n        );\\n        require(distance**2 <= distanceSquared && distanceSquared < (distance + 1)**2, \\\"wrong distance\\\");\\n    }\\n\\n    function _requireCorrectTimeAndUpdateArrivalTime(\\n        uint256 distance,\\n        uint256 arrivalTimeWanted,\\n        uint40 launchTime,\\n        bytes32 fromPlanetData,\\n        ResolutionState memory rState\\n    ) internal view {\\n        uint256 reachTime = Math.max(\\n            arrivalTimeWanted,\\n            launchTime + (distance * (_timePerDistance * 10000)) / _speed(fromPlanetData)\\n        );\\n        rState.arrivalTime = uint40(reachTime);\\n        require(block.timestamp >= reachTime, \\\"too early\\\");\\n        require(block.timestamp < reachTime + _resolveWindow, \\\"too late, your spaceships are lost in space\\\");\\n    }\\n\\n    function _activeNumSpaceships(uint32 numSpaceshipsData) internal pure returns (bool active, uint32 numSpaceships) {\\n        active = (numSpaceshipsData & ACTIVE_MASK) == ACTIVE_MASK;\\n        numSpaceships = numSpaceshipsData % (ACTIVE_MASK);\\n    }\\n\\n    function _setActiveNumSpaceships(bool active, uint32 numSpaceships) internal pure returns (uint32) {\\n        return uint32((active ? ACTIVE_MASK : 0) + numSpaceships);\\n    }\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender; // TODO metatx\\n    }\\n}\\n\",\"keccak256\":\"0x3bfb18a7346144deff0004b8831380387dd1bd5a497e0adeb0fa814fde5ff96c\",\"license\":\"AGPL-3.0\"},\"src/outerspace/facets/OuterSpacePlanetsFacet.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"./OuterSpaceFacetBase.sol\\\";\\nimport \\\"../interfaces/IOuterSpacePlanets.sol\\\";\\nimport \\\"../interfaces/IApprovalReceiver.sol\\\";\\n\\ncontract OuterSpacePlanetsFacet is OuterSpaceFacetBase, IOuterSpacePlanets {\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor(Config memory config) OuterSpaceFacetBase(config) {}\\n\\n    function setApprovalForAll(address operator, bool approved) external {\\n        address sender = _msgSender();\\n        _operators[sender][operator] = approved;\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    function setApprovalForAllIfNeededAndCall(IApprovalReceiver operator, bytes calldata data) external {\\n        address sender = _msgSender();\\n        if (!_operators[sender][address(operator)]) {\\n            _operators[sender][address(operator)] = true;\\n            emit ApprovalForAll(sender, address(operator), true);\\n        }\\n        operator.onApprovalForAllBy(sender, data);\\n    }\\n\\n    function ownerOf(uint256 location) external view returns (address currentOwner) {\\n        Planet storage planet = _getPlanet(location);\\n        currentOwner = planet.owner;\\n        // TODO should we ?\\n        // if (_hasJustExited(_planets[location].exitStartTime)) {\\n        //     currentOwner = address(0);\\n        // } else {\\n        //     PlanetUpdateState memory planetUpdate = _createPlanetUpdateState(planet, location);\\n        //     _computePlanetUpdateForTimeElapsed(planetUpdate);\\n        //     if (!planetUpdate.active && planetUpdate.numSpaceships == 0) {\\n        //         currentOwner = address(0);\\n        //     }\\n        // }\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\\n        return _operators[owner][operator];\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 location) external {\\n        // TODO safe callback\\n        _transfer(from, to, location);\\n    }\\n    function safeTransferFrom(address from, address to, uint256 location, bytes calldata data) external {\\n        // TODO safe callback + data\\n        _transfer(from, to, location);\\n    }\\n    function transferFrom(address from, address to, uint256 location) external {\\n        _transfer(from, to, location);\\n    }\\n\\n    function _transfer(address from, address to, uint256 location) internal {\\n        require(from != address(0), \\\"NOT_ZERO_ADDRESS\\\");\\n\\n        // TODO extract, see ownerOf (same code)\\n        address currentOwner = _planets[location].owner;\\n        if (_hasJustExited(_planets[location].exitStartTime)) {\\n            currentOwner = address(0);\\n        }\\n\\n        require(currentOwner == from, \\\"FROM_NOT_OWNER\\\");\\n        if (msg.sender != currentOwner) {\\n            require(_operators[currentOwner][msg.sender], \\\"NOT_OPERATOR\\\");\\n        }\\n\\n        _planets[location].owner = to;\\n        _planets[location].ownershipStartTime = uint40(block.timestamp);\\n\\n        emit Transfer(from, to, location);\\n    }\\n\\n    function ownerAndOwnershipStartTimeOf(uint256 location) external view returns (address owner, uint40 ownershipStartTime) {\\n        owner = _planets[location].owner;\\n        ownershipStartTime = _planets[location].ownershipStartTime;\\n    }\\n\\n    function getPlanetState(uint256 location) external view returns (Planet memory state) {\\n        return _planets[location];\\n    }\\n\\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats) {\\n        Planet storage planet = _getPlanet(location);\\n        (bool active, uint32 numSpaceships) = _activeNumSpaceships(planet.numSpaceships);\\n        state = ExternalPlanet({\\n            owner: planet.owner,\\n            ownershipStartTime: planet.ownershipStartTime,\\n            exitStartTime: planet.exitStartTime,\\n            numSpaceships: numSpaceships,\\n            overflow: planet.overflow,\\n            lastUpdated: planet.lastUpdated,\\n            active: active,\\n            reward: _rewards[location]\\n        });\\n        stats = _getPlanetStats(location);\\n    }\\n}\\n\",\"keccak256\":\"0xa7e3419e522baf5fc485c55cadd33952d0d099d3457db71dd92fac50a841865b\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IApprovalReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\ninterface IApprovalReceiver {\\n    function onApprovalForAllBy(address owner, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x849c7e92968908bff9ec28f343a37116fed52fb95163548f92a5e2eb52148f0d\",\"license\":\"AGPL-3.0\"},\"src/outerspace/interfaces/IOuterSpacePlanets.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../types/ImportingOuterSpaceTypes.sol\\\";\\nimport \\\"../events/ImportingOuterSpaceEvents.sol\\\";\\n\\ninterface IOuterSpacePlanets is ImportingOuterSpaceTypes, ImportingOuterSpaceEvents {\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function ownerOf(uint256 location) external view returns (address);\\n\\n    function safeTransferFrom(address from, address to, uint256 location) external;\\n    function safeTransferFrom(address from, address to, uint256 location, bytes calldata data) external;\\n    function transferFrom(address from, address to, uint256 location) external;\\n\\n    function ownerAndOwnershipStartTimeOf(uint256 location) external view returns (address owner, uint40 ownershipStartTime);\\n\\n    function getPlanet(uint256 location) external view returns (ExternalPlanet memory state, PlanetStats memory stats);\\n\\n    function getPlanetState(uint256 location) external view returns (Planet memory state);\\n}\\n\",\"keccak256\":\"0x21f7b75b301559a35dc866dde7aa3f01b51f08c9ee50ca768549fbe1377c94d9\",\"license\":\"AGPL-3.0\"},\"src/outerspace/types/ImportingOuterSpaceTypes.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ImportingOuterSpaceTypes {\\n    // front running protection : _frontruunningDelay / 2 slots\\n    struct InFlight {\\n        uint32 flying;\\n        uint32 destroyed;\\n        // STORE last attack too, to compute combined attack on it ? uint128 is plainty enough\\n    }\\n\\n    // TODO remove\\n    // struct Account {\\n    //     // TODO add more info\\n    //     // stake for example ? => coild it be used by staking ?\\n    //     // numPlanets ?\\n    //     // numSpaceships ? => probably too much ?\\n    //     uint64 totalProduction;\\n    //     uint64 productionDebt;\\n    // }\\n\\n    struct Discovered {\\n        uint32 minX;\\n        uint32 maxX;\\n        uint32 minY;\\n        uint32 maxY;\\n    }\\n\\n    // TODO split in 2 structs ? PlanetOwnership and PlanetState ?\\n    struct Planet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        // TODO uint16 ?\\n        ///\\n        uint32 numSpaceships; // uint31 + first bit => active // TODO use bool active ?\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        int40 travelingUpkeep; // decrease per _upkeepProductionDecreaseRatePer10000th  * production\\n        uint32 overflow;\\n        // bool active; // TODO ?\\n        // bool exiting; // TODO ?\\n    }\\n\\n    struct Fleet {\\n        address owner;\\n        uint40 launchTime; // ~ 34865 years, should be enough :)\\n        uint32 quantity; // TODO? first bit = done? to keep quantity value on-chain post resolution, actually not needed, can be given in the hash\\n        // we got 24bit more to store if needed\\n        // operator ? // signer ?\\n    }\\n\\n    struct PlanetStats {\\n        int8 subX;\\n        int8 subY;\\n        uint16 stake;\\n        uint16 production;\\n        uint16 attack;\\n        uint16 defense;\\n        uint16 speed;\\n        uint16 natives;\\n    }\\n\\n    struct ExternalPlanet {\\n        address owner;\\n        uint40 ownershipStartTime; // ~ 34865 years, should be enough :)\\n        uint40 exitStartTime; // ~ 34865 years, should be enough :)\\n        uint32 numSpaceships;\\n        uint32 overflow;\\n        uint40 lastUpdated; // ~ 34865 years, should be enough :)\\n        bool active;\\n        // bool exiting;\\n        uint256 reward;\\n    }\\n\\n    struct FleetLaunch {\\n        address fleetSender;\\n        address fleetOwner;\\n        uint256 from;\\n        uint32 quantity;\\n        bytes32 toHash;\\n    }\\n    struct FleetResolution {\\n        uint256 from;\\n        uint256 to;\\n        uint256 distance;\\n        uint256 arrivalTimeWanted;\\n        bool gift;\\n        address specific;\\n        bytes32 secret;\\n        address fleetSender; // does not work ?\\n        address operator; // should be saved ?\\n    }\\n\\n    struct AccumulatedAttack {\\n        address target;\\n        uint32 numAttackSpent;\\n        uint32 damageCausedSoFar;\\n        uint16 averageAttackPower;\\n    }\\n}\\n\",\"keccak256\":\"0xde203f8ac79d1cce8910e4208fc94b79008b4267f50b39c44a6a1d409282cf8d\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x6102006040523480156200001257600080fd5b5060405162001ae838038062001ae88339810160408190526200003591620001a6565b806000600482608001516200004b919062000267565b60808301519091506200006082600462000299565b63ffffffff1614620000b85760405162461bcd60e51b815260206004820152601d60248201527f54494d455f5045525f444953545f4e4f545f444956495349424c455f34000000604482015260640160405180910390fd5b81516001600160a01b0390811660805260208301511660a0908152604083015160c0908152606084015160e090815263ffffffff938416610100908152928501516101209081529185015184166101409081529085015190931661016090815291840151610180528301516101a052908201516101c05201516101e05250620002d4565b60405161018081016001600160401b03811182821017156200016e57634e487b7160e01b600052604160045260246000fd5b60405290565b80516001600160a01b03811681146200018c57600080fd5b919050565b805163ffffffff811681146200018c57600080fd5b60006101808284031215620001ba57600080fd5b620001c46200013c565b620001cf8362000174565b8152620001df6020840162000174565b602082015260408301516040820152606083015160608201526080830151608082015260a083015160a08201526200021a60c0840162000191565b60c08201526200022d60e0840162000191565b60e0820152610100838101519082015261012080840151908201526101408084015190820152610160928301519281019290925250919050565b600063ffffffff808416806200028d57634e487b7160e01b600052601260045260246000fd5b92169190910492915050565b600063ffffffff80831681851681830481118215151615620002cb57634e487b7160e01b600052601160045260246000fd5b02949350505050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a0516101c0516101e0516117a0620003486000396000505060005050600050506000505060005050600050506000610c5e015260005050600050506000610af8015260005050600050506117a06000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c8063a22cb46511610076578063d522989e1161005b578063d522989e1461020d578063d61b2c1e146103b1578063e985e9c5146103c457600080fd5b8063a22cb465146101e7578063b88d4fde146101fa57600080fd5b806342842e0e116100a757806342842e0e146100c35780636352211e146101025780638a886cd51461015d57600080fd5b806323b872dd146100c357806334efcb8e146100d8575b600080fd5b6100d66100d13660046111ef565b6103e7565b005b6100eb6100e6366004611230565b6103f7565b6040516100f9929190611249565b60405180910390f35b610138610110366004611230565b60009081526020819052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f9565b6101b561016b366004611230565b60009081526020819052604090205473ffffffffffffffffffffffffffffffffffffffff8116917401000000000000000000000000000000000000000090910464ffffffffff1690565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835264ffffffffff9091166020830152016100f9565b6100d66101f5366004611363565b610586565b6100d66102083660046113ea565b61061c565b61032661021b366004611230565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c08101919091525060009081526020818152604091829020825160e081018452815473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff74010000000000000000000000000000000000000000820481169483019490945279010000000000000000000000000000000000000000000000000090048316938101939093526001015463ffffffff8082166060850152640100000000820490921660808401526901000000000000000000810460040b60a08401526e01000000000000000000000000000090041660c082015290565b6040516100f99190600060e08201905073ffffffffffffffffffffffffffffffffffffffff8351168252602083015164ffffffffff80821660208501528060408601511660408501526060850151915063ffffffff808316606086015281608087015116608086015260a086015160040b60a08601528060c08701511660c086015250505092915050565b6100d66103bf36600461145d565b61062e565b6103d76103d23660046114b2565b610787565b60405190151581526020016100f9565b6103f28383836107c4565b505050565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091526040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091526000838152602081905260408120600181015490915060009081906104a39063ffffffff16610a92565b6040805161010081018252865473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff740100000000000000000000000000000000000000008204811660208085019190915279010000000000000000000000000000000000000000000000000090920481168385015263ffffffff808616606085015260018a01546e0100000000000000000000000000008104909116608085015264010000000090041660a083015284151560c083015260008b81526007909152919091205460e08201529650909250905061057c86610ab1565b9350505050915091565b33600081815260036020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168615159081179091558151908152905184927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31928290030190a3505050565b6106278585856107c4565b5050505050565b33600081815260036020908152604080832073ffffffffffffffffffffffffffffffffffffffff8816845290915290205460ff166106f95773ffffffffffffffffffffffffffffffffffffffff81811660008181526003602090815260408083209489168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35b6040517fcffb4f5100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063cffb4f519061074f908490879087906004016114e0565b600060405180830381600087803b15801561076957600080fd5b505af115801561077d573d6000803e3d6000fd5b5050505050505050565b73ffffffffffffffffffffffffffffffffffffffff80831660009081526003602090815260408083209385168352929052205460ff165b92915050565b73ffffffffffffffffffffffffffffffffffffffff8316610846576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4e4f545f5a45524f5f414444524553530000000000000000000000000000000060448201526064015b60405180910390fd5b60008181526020819052604090205473ffffffffffffffffffffffffffffffffffffffff81169061089a90790100000000000000000000000000000000000000000000000000900464ffffffffff16610c46565b156108a3575060005b8373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610938576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f46524f4d5f4e4f545f4f574e4552000000000000000000000000000000000000604482015260640161083d565b3373ffffffffffffffffffffffffffffffffffffffff8216146109ef5773ffffffffffffffffffffffffffffffffffffffff8116600090815260036020908152604080832033845290915290205460ff166109ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e4f545f4f50455241544f520000000000000000000000000000000000000000604482015260640161083d565b600082815260208190526040808220805473ffffffffffffffffffffffffffffffffffffffff8781167fffffffffffffff000000000000000000000000000000000000000000000000009092168217740100000000000000000000000000000000000000004264ffffffffff16021790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b6380000000818116811490600090610aaa9084611579565b9050915091565b60408051610100810182526000808252602080830182905282840182905260608084018390526080840183905260a0840183905260c0840183905260e084019290925283517f00000000000000000000000000000000000000000000000000000000000000008183015280850186905284518082038601815292019093528051920191909120610b4081610c92565b610ba6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f6e6f20706c616e657420696e2074686973206c6f636174696f6e000000000000604482015260640161083d565b600080610bb283610cae565b915091506040518061010001604052808360000b81526020018260000b8152602001610bdd85610ce2565b61ffff168152602001610bef85610db9565b61ffff168152602001610c0185610e56565b61ffff168152602001610c1385610eed565b61ffff168152602001610c2585610f69565b61ffff168152602001610c3785611000565b61ffff16905295945050505050565b6000808264ffffffffff161180156107be5750610c8a7f000000000000000000000000000000000000000000000000000000000000000064ffffffffff84166115cb565b421192915050565b6000610ca18260346010611097565b60ff166001149050919050565b600080610cbd83826003611097565b610cc89060016115e3565b9150610cd78360026003611097565b610aaa9060016115e3565b6000610ced82610c92565b610d53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b6000610d6083600c6110b6565b905060ff81167e060008000a000c000e00100012001400140016001800200028003000380048610d91826002611645565b610d9c90600161166f565b61ffff1660208110610db057610db0611695565b1a949350505050565b6000610dc482610c92565b610e2a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b6107be82600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0611150565b6000610e6182610c92565b610ec7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610ed28260146110b6565b610ee19060ff16610190611645565b6107be90610fa061166f565b6000610ef882610c92565b610f5e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610ed282601c6110b6565b6000610f7482610c92565b610fda576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610fe58260246110b6565b610ff49060ff1661014d611645565b6107be9061138d61166f565b600061100b82610c92565b611071576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b61107c82602c6110b6565b61108b9060ff16610bb8611645565b6107be90613a9861166f565b60006110ac60ff80841690851686901c6116c4565b90505b9392505050565b6000806110c584846040611097565b905060006110d46002836116d8565b905060006110e36002846116fa565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff84166020811061111c5761111c611695565b1a905060ff821661113a5760048160ff16901c9450505050506107be565b6111456010826116fa565b9450505050506107be565b60008061115d85856110b6565b90508261116b82600261171c565b611176906001611745565b60ff166020811061118957611189611695565b1a8361119683600261171c565b60ff16602081106111a9576111a9611695565b6111b791901a610100611645565b6111c1919061166f565b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff811681146111ec57600080fd5b50565b60008060006060848603121561120457600080fd5b833561120f816111ca565b9250602084013561121f816111ca565b929592945050506040919091013590565b60006020828403121561124257600080fd5b5035919050565b60006102008201905073ffffffffffffffffffffffffffffffffffffffff8451168252602084015164ffffffffff8082166020850152806040870151166040850152505060608401516112a4606084018263ffffffff169052565b5060808401516112bc608084018263ffffffff169052565b5060a08401516112d560a084018264ffffffffff169052565b5060c08401516112e960c084018215159052565b5060e084810151838201528351600090810b6101008501526020850151900b610120840152604084015161ffff908116610140850152606085015181166101608501526080850151811661018085015260a085015181166101a085015260c085015181166101c085015290840151166101e08301526110af565b6000806040838503121561137657600080fd5b8235611381816111ca565b91506020830135801515811461139657600080fd5b809150509250929050565b60008083601f8401126113b357600080fd5b50813567ffffffffffffffff8111156113cb57600080fd5b6020830191508360208285010111156113e357600080fd5b9250929050565b60008060008060006080868803121561140257600080fd5b853561140d816111ca565b9450602086013561141d816111ca565b935060408601359250606086013567ffffffffffffffff81111561144057600080fd5b61144c888289016113a1565b969995985093965092949392505050565b60008060006040848603121561147257600080fd5b833561147d816111ca565b9250602084013567ffffffffffffffff81111561149957600080fd5b6114a5868287016113a1565b9497909650939450505050565b600080604083850312156114c557600080fd5b82356114d0816111ca565b91506020830135611396816111ca565b73ffffffffffffffffffffffffffffffffffffffff8416815260406020820152816040820152818360608301376000818301606090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600063ffffffff808416806115905761159061154a565b92169190910692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082198211156115de576115de61159c565b500190565b60008160000b8360000b60008112817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80018312811516156116265761162661159c565b81607f01831381161561163b5761163b61159c565b5090039392505050565b600061ffff808316818516818304811182151516156116665761166661159c565b02949350505050565b600061ffff80831681851680830382111561168c5761168c61159c565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000826116d3576116d361154a565b500690565b600060ff8316806116eb576116eb61154a565b8060ff84160491505092915050565b600060ff83168061170d5761170d61154a565b8060ff84160691505092915050565b600060ff821660ff84168160ff048111821515161561173d5761173d61159c565b029392505050565b600060ff821660ff84168060ff038211156117625761176261159c565b01939250505056fea26469706673582212205b8abd598695782e8059353e12915f6edb8e27ca2050af81399ac5d42e1d18b264736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100be5760003560e01c8063a22cb46511610076578063d522989e1161005b578063d522989e1461020d578063d61b2c1e146103b1578063e985e9c5146103c457600080fd5b8063a22cb465146101e7578063b88d4fde146101fa57600080fd5b806342842e0e116100a757806342842e0e146100c35780636352211e146101025780638a886cd51461015d57600080fd5b806323b872dd146100c357806334efcb8e146100d8575b600080fd5b6100d66100d13660046111ef565b6103e7565b005b6100eb6100e6366004611230565b6103f7565b6040516100f9929190611249565b60405180910390f35b610138610110366004611230565b60009081526020819052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f9565b6101b561016b366004611230565b60009081526020819052604090205473ffffffffffffffffffffffffffffffffffffffff8116917401000000000000000000000000000000000000000090910464ffffffffff1690565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835264ffffffffff9091166020830152016100f9565b6100d66101f5366004611363565b610586565b6100d66102083660046113ea565b61061c565b61032661021b366004611230565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c08101919091525060009081526020818152604091829020825160e081018452815473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff74010000000000000000000000000000000000000000820481169483019490945279010000000000000000000000000000000000000000000000000090048316938101939093526001015463ffffffff8082166060850152640100000000820490921660808401526901000000000000000000810460040b60a08401526e01000000000000000000000000000090041660c082015290565b6040516100f99190600060e08201905073ffffffffffffffffffffffffffffffffffffffff8351168252602083015164ffffffffff80821660208501528060408601511660408501526060850151915063ffffffff808316606086015281608087015116608086015260a086015160040b60a08601528060c08701511660c086015250505092915050565b6100d66103bf36600461145d565b61062e565b6103d76103d23660046114b2565b610787565b60405190151581526020016100f9565b6103f28383836107c4565b505050565b6040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091526040805161010081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101919091526000838152602081905260408120600181015490915060009081906104a39063ffffffff16610a92565b6040805161010081018252865473ffffffffffffffffffffffffffffffffffffffff8116825264ffffffffff740100000000000000000000000000000000000000008204811660208085019190915279010000000000000000000000000000000000000000000000000090920481168385015263ffffffff808616606085015260018a01546e0100000000000000000000000000008104909116608085015264010000000090041660a083015284151560c083015260008b81526007909152919091205460e08201529650909250905061057c86610ab1565b9350505050915091565b33600081815260036020908152604080832073ffffffffffffffffffffffffffffffffffffffff87168085529083529281902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00168615159081179091558151908152905184927f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31928290030190a3505050565b6106278585856107c4565b5050505050565b33600081815260036020908152604080832073ffffffffffffffffffffffffffffffffffffffff8816845290915290205460ff166106f95773ffffffffffffffffffffffffffffffffffffffff81811660008181526003602090815260408083209489168084529482529182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915591519182527f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31910160405180910390a35b6040517fcffb4f5100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff85169063cffb4f519061074f908490879087906004016114e0565b600060405180830381600087803b15801561076957600080fd5b505af115801561077d573d6000803e3d6000fd5b5050505050505050565b73ffffffffffffffffffffffffffffffffffffffff80831660009081526003602090815260408083209385168352929052205460ff165b92915050565b73ffffffffffffffffffffffffffffffffffffffff8316610846576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601060248201527f4e4f545f5a45524f5f414444524553530000000000000000000000000000000060448201526064015b60405180910390fd5b60008181526020819052604090205473ffffffffffffffffffffffffffffffffffffffff81169061089a90790100000000000000000000000000000000000000000000000000900464ffffffffff16610c46565b156108a3575060005b8373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614610938576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f46524f4d5f4e4f545f4f574e4552000000000000000000000000000000000000604482015260640161083d565b3373ffffffffffffffffffffffffffffffffffffffff8216146109ef5773ffffffffffffffffffffffffffffffffffffffff8116600090815260036020908152604080832033845290915290205460ff166109ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600c60248201527f4e4f545f4f50455241544f520000000000000000000000000000000000000000604482015260640161083d565b600082815260208190526040808220805473ffffffffffffffffffffffffffffffffffffffff8781167fffffffffffffff000000000000000000000000000000000000000000000000009092168217740100000000000000000000000000000000000000004264ffffffffff16021790925591518593918816917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a450505050565b6380000000818116811490600090610aaa9084611579565b9050915091565b60408051610100810182526000808252602080830182905282840182905260608084018390526080840183905260a0840183905260c0840183905260e084019290925283517f00000000000000000000000000000000000000000000000000000000000000008183015280850186905284518082038601815292019093528051920191909120610b4081610c92565b610ba6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f6e6f20706c616e657420696e2074686973206c6f636174696f6e000000000000604482015260640161083d565b600080610bb283610cae565b915091506040518061010001604052808360000b81526020018260000b8152602001610bdd85610ce2565b61ffff168152602001610bef85610db9565b61ffff168152602001610c0185610e56565b61ffff168152602001610c1385610eed565b61ffff168152602001610c2585610f69565b61ffff168152602001610c3785611000565b61ffff16905295945050505050565b6000808264ffffffffff161180156107be5750610c8a7f000000000000000000000000000000000000000000000000000000000000000064ffffffffff84166115cb565b421192915050565b6000610ca18260346010611097565b60ff166001149050919050565b600080610cbd83826003611097565b610cc89060016115e3565b9150610cd78360026003611097565b610aaa9060016115e3565b6000610ced82610c92565b610d53576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b6000610d6083600c6110b6565b905060ff81167e060008000a000c000e00100012001400140016001800200028003000380048610d91826002611645565b610d9c90600161166f565b61ffff1660208110610db057610db0611695565b1a949350505050565b6000610dc482610c92565b610e2a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b6107be82600c7f0708083409600a8c0bb80ce40e100e100e100e101068151819c81e7823282ee0611150565b6000610e6182610c92565b610ec7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610ed28260146110b6565b610ee19060ff16610190611645565b6107be90610fa061166f565b6000610ef882610c92565b610f5e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610ed282601c6110b6565b6000610f7482610c92565b610fda576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b610fe58260246110b6565b610ff49060ff1661014d611645565b6107be9061138d61166f565b600061100b82610c92565b611071576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f504c414e45545f4e4f545f455849535453000000000000000000000000000000604482015260640161083d565b61107c82602c6110b6565b61108b9060ff16610bb8611645565b6107be90613a9861166f565b60006110ac60ff80841690851686901c6116c4565b90505b9392505050565b6000806110c584846040611097565b905060006110d46002836116d8565b905060006110e36002846116fa565b905060007f01223334444555555666666677777777888888889999999aaaaaabbbbcccddef60ff84166020811061111c5761111c611695565b1a905060ff821661113a5760048160ff16901c9450505050506107be565b6111456010826116fa565b9450505050506107be565b60008061115d85856110b6565b90508261116b82600261171c565b611176906001611745565b60ff166020811061118957611189611695565b1a8361119683600261171c565b60ff16602081106111a9576111a9611695565b6111b791901a610100611645565b6111c1919061166f565b95945050505050565b73ffffffffffffffffffffffffffffffffffffffff811681146111ec57600080fd5b50565b60008060006060848603121561120457600080fd5b833561120f816111ca565b9250602084013561121f816111ca565b929592945050506040919091013590565b60006020828403121561124257600080fd5b5035919050565b60006102008201905073ffffffffffffffffffffffffffffffffffffffff8451168252602084015164ffffffffff8082166020850152806040870151166040850152505060608401516112a4606084018263ffffffff169052565b5060808401516112bc608084018263ffffffff169052565b5060a08401516112d560a084018264ffffffffff169052565b5060c08401516112e960c084018215159052565b5060e084810151838201528351600090810b6101008501526020850151900b610120840152604084015161ffff908116610140850152606085015181166101608501526080850151811661018085015260a085015181166101a085015260c085015181166101c085015290840151166101e08301526110af565b6000806040838503121561137657600080fd5b8235611381816111ca565b91506020830135801515811461139657600080fd5b809150509250929050565b60008083601f8401126113b357600080fd5b50813567ffffffffffffffff8111156113cb57600080fd5b6020830191508360208285010111156113e357600080fd5b9250929050565b60008060008060006080868803121561140257600080fd5b853561140d816111ca565b9450602086013561141d816111ca565b935060408601359250606086013567ffffffffffffffff81111561144057600080fd5b61144c888289016113a1565b969995985093965092949392505050565b60008060006040848603121561147257600080fd5b833561147d816111ca565b9250602084013567ffffffffffffffff81111561149957600080fd5b6114a5868287016113a1565b9497909650939450505050565b600080604083850312156114c557600080fd5b82356114d0816111ca565b91506020830135611396816111ca565b73ffffffffffffffffffffffffffffffffffffffff8416815260406020820152816040820152818360608301376000818301606090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016010192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b600063ffffffff808416806115905761159061154a565b92169190910692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082198211156115de576115de61159c565b500190565b60008160000b8360000b60008112817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80018312811516156116265761162661159c565b81607f01831381161561163b5761163b61159c565b5090039392505050565b600061ffff808316818516818304811182151516156116665761166661159c565b02949350505050565b600061ffff80831681851680830382111561168c5761168c61159c565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000826116d3576116d361154a565b500690565b600060ff8316806116eb576116eb61154a565b8060ff84160491505092915050565b600060ff83168061170d5761170d61154a565b8060ff84160691505092915050565b600060ff821660ff84168160ff048111821515161561173d5761173d61159c565b029392505050565b600060ff821660ff84168060ff038211156117625761176261159c565b01939250505056fea26469706673582212205b8abd598695782e8059353e12915f6edb8e27ca2050af81399ac5d42e1d18b264736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 16595,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_planets",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Planet)22896_storage)"
      },
      {
        "astId": 16600,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_fleets",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_struct(Fleet)22903_storage)"
      },
      {
        "astId": 16604,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_stakeReadyToBeWithdrawn",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 16610,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_operators",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 16617,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_inFlight",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(InFlight)22872_storage))"
      },
      {
        "astId": 16620,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_discovered",
        "offset": 0,
        "slot": "5",
        "type": "t_struct(Discovered)22881_storage"
      },
      {
        "astId": 16624,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_prevRewardIds",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 16628,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_rewards",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 16634,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_rewardsToWithdraw",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_address,t_mapping(t_uint256,t_bool))"
      },
      {
        "astId": 16643,
        "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
        "label": "_attacks",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage)))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_int40": {
        "encoding": "inplace",
        "label": "int40",
        "numberOfBytes": "5"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_bool))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_bool)"
      },
      "t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage)))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack)))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage))"
      },
      "t_mapping(t_uint256,t_mapping(t_uint256,t_struct(InFlight)22872_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(uint256 => struct ImportingOuterSpaceTypes.InFlight))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint256,t_struct(InFlight)22872_storage)"
      },
      "t_mapping(t_uint256,t_struct(AccumulatedAttack)22976_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.AccumulatedAttack)",
        "numberOfBytes": "32",
        "value": "t_struct(AccumulatedAttack)22976_storage"
      },
      "t_mapping(t_uint256,t_struct(Fleet)22903_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.Fleet)",
        "numberOfBytes": "32",
        "value": "t_struct(Fleet)22903_storage"
      },
      "t_mapping(t_uint256,t_struct(InFlight)22872_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.InFlight)",
        "numberOfBytes": "32",
        "value": "t_struct(InFlight)22872_storage"
      },
      "t_mapping(t_uint256,t_struct(Planet)22896_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ImportingOuterSpaceTypes.Planet)",
        "numberOfBytes": "32",
        "value": "t_struct(Planet)22896_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(AccumulatedAttack)22976_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.AccumulatedAttack",
        "members": [
          {
            "astId": 22969,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "target",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 22971,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "numAttackSpent",
            "offset": 20,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22973,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "damageCausedSoFar",
            "offset": 24,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22975,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "averageAttackPower",
            "offset": 28,
            "slot": "0",
            "type": "t_uint16"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Discovered)22881_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Discovered",
        "members": [
          {
            "astId": 22874,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "minX",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22876,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "maxX",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22878,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "minY",
            "offset": 8,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22880,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "maxY",
            "offset": 12,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Fleet)22903_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Fleet",
        "members": [
          {
            "astId": 22898,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 22900,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "launchTime",
            "offset": 20,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 22902,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "quantity",
            "offset": 25,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(InFlight)22872_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.InFlight",
        "members": [
          {
            "astId": 22869,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "flying",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 22871,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "destroyed",
            "offset": 4,
            "slot": "0",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Planet)22896_storage": {
        "encoding": "inplace",
        "label": "struct ImportingOuterSpaceTypes.Planet",
        "members": [
          {
            "astId": 22883,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 22885,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "ownershipStartTime",
            "offset": 20,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 22887,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "exitStartTime",
            "offset": 25,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 22889,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "numSpaceships",
            "offset": 0,
            "slot": "1",
            "type": "t_uint32"
          },
          {
            "astId": 22891,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "lastUpdated",
            "offset": 4,
            "slot": "1",
            "type": "t_uint40"
          },
          {
            "astId": 22893,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "travelingUpkeep",
            "offset": 9,
            "slot": "1",
            "type": "t_int40"
          },
          {
            "astId": 22895,
            "contract": "src/outerspace/facets/OuterSpacePlanetsFacet.sol:OuterSpacePlanetsFacet",
            "label": "overflow",
            "offset": 14,
            "slot": "1",
            "type": "t_uint32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint40": {
        "encoding": "inplace",
        "label": "uint40",
        "numberOfBytes": "5"
      }
    }
  }
}